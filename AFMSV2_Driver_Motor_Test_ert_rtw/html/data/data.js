var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"AFMSV2_Driver_Motor_Test","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\r\n * ert_main.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"AFMSV2_Driver_Motor_Test.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nvolatile int IsrOverrun = 0;\r\nstatic boolean_T OverrunFlag = 0;\r\nvoid rt_OneStep(void)\r\n{\r\n  /* Check for overrun. Protect OverrunFlag against preemption */\r\n  if (OverrunFlag++) {\r\n    IsrOverrun = 1;\r\n    OverrunFlag--;\r\n    return;\r\n  }\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  interrupts();\r\n\r\n#endif;\r\n\r\n  AFMSV2_Driver_Motor_Test_step();\r\n\r\n  /* Get model outputs here */\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  noInterrupts();\r\n\r\n#endif;\r\n\r\n  OverrunFlag--;\r\n}\r\n\r\nvolatile boolean_T stopRequested;\r\nvolatile boolean_T runModel;\r\nint main(void)\r\n{\r\n  float modelBaseRate = 0.1;\r\n  float systemClock = 0;\r\n\r\n  /* Initialize variables */\r\n  stopRequested = false;\r\n  runModel = false;\r\n\r\n#if defined(MW_MULTI_TASKING_MODE) && (MW_MULTI_TASKING_MODE == 1)\r\n\r\n  MW_ASM (\" SVC #1\");\r\n\r\n#endif\r\n\r\n  ;\r\n  init();\r\n  MW_Arduino_Init();\r\n  rtmSetErrorStatus(AFMSV2_Driver_Motor_Test_M, 0);\r\n  AFMSV2_Driver_Motor_Test_initialize();\r\n  noInterrupts();\r\n  configureArduinoARMTimer();\r\n  runModel =\r\n    rtmGetErrorStatus(AFMSV2_Driver_Motor_Test_M) == (NULL);\r\n\r\n#ifndef _MW_ARDUINO_LOOP_\r\n\r\n  interrupts();\r\n\r\n#endif;\r\n\r\n  interrupts();\r\n  while (runModel) {\r\n    stopRequested = !(\r\n                      rtmGetErrorStatus(AFMSV2_Driver_Motor_Test_M) == (NULL));\r\n    MW_Arduino_Loop();\r\n  }\r\n\r\n  /* Terminate model */\r\n  AFMSV2_Driver_Motor_Test_terminate();\r\n  MW_Arduino_Terminate();\r\n  noInterrupts();\r\n  return 0;\r\n}\r\n"},{"name":"AFMSV2_Driver_Motor_Test.c","type":"source","group":"model","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * AFMSV2_Driver_Motor_Test.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"AFMSV2_Driver_Motor_Test.h\"\r\n#include \"AFMSV2_Driver_Motor_Test_private.h\"\r\n\r\n/* Block states (default storage) */\r\nDW_AFMSV2_Driver_Motor_Test_T AFMSV2_Driver_Motor_Test_DW;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_AFMSV2_Driver_Motor__T AFMSV2_Driver_Motor_Test_M_;\r\nRT_MODEL_AFMSV2_Driver_Motor__T *const AFMSV2_Driver_Motor_Test_M =\r\n  &AFMSV2_Driver_Motor_Test_M_;\r\n\r\n/* Model step function */\r\nvoid AFMSV2_Driver_Motor_Test_step(void)\r\n{\r\n  real_T sampleTime;\r\n\r\n  /* MATLABSystem: '<Root>/MATLAB System' incorporates:\r\n   *  Constant: '<Root>/Constant'\r\n   */\r\n  if (AFMSV2_Driver_Motor_Test_DW.obj.SampleTime !=\r\n      AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime) {\r\n    if (((!rtIsInf(AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime)) &&\r\n         (!rtIsNaN(AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime))) ||\r\n        rtIsInf(AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime)) {\r\n      sampleTime = AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime;\r\n    }\r\n\r\n    AFMSV2_Driver_Motor_Test_DW.obj.SampleTime = sampleTime;\r\n  }\r\n\r\n  /*         %% Define output properties */\r\n  /* 'AFMSV2Driver:71' num = 4; */\r\n  /* 'AFMSV2Driver:75' num = 0; */\r\n  /* 'AFMSV2Driver:50' if isempty(coder.target) */\r\n  /* 'AFMSV2Driver:52' else */\r\n  /*  Call C-function implementing device output */\r\n  /* 'AFMSV2Driver:54' coder.ceval('AFMSV2Driver_Step', U1, U2, U3, U4); */\r\n  AFMSV2Driver_Step(AFMSV2_Driver_Motor_Test_P.Constant_Value,\r\n                    AFMSV2_Driver_Motor_Test_P.Constant_Value,\r\n                    AFMSV2_Driver_Motor_Test_P.Constant_Value,\r\n                    AFMSV2_Driver_Motor_Test_P.Constant_Value);\r\n\r\n  /* End of MATLABSystem: '<Root>/MATLAB System' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid AFMSV2_Driver_Motor_Test_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(AFMSV2_Driver_Motor_Test_M, (NULL));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&AFMSV2_Driver_Motor_Test_DW, 0,\r\n                sizeof(DW_AFMSV2_Driver_Motor_Test_T));\r\n\r\n  {\r\n    real_T sampleTime;\r\n\r\n    /* Start for MATLABSystem: '<Root>/MATLAB System' */\r\n    /*  Constructor */\r\n    /* 'AFMSV2Driver:1' realtime.internal.SourceSampleTime */\r\n    /* 'AFMSV2Driver:2' coder.ExternalDependency */\r\n    /*  Support name-value pair arguments when constructing the object. */\r\n    /* 'AFMSV2Driver:34' setProperties(obj,nargin,varargin{:}); */\r\n    AFMSV2_Driver_Motor_Test_DW.obj.matlabCodegenIsDeleted = false;\r\n    if (((!rtIsInf(AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime)) &&\r\n         (!rtIsNaN(AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime))) ||\r\n        rtIsInf(AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime)) {\r\n      sampleTime = AFMSV2_Driver_Motor_Test_P.MATLABSystem_SampleTime;\r\n    }\r\n\r\n    AFMSV2_Driver_Motor_Test_DW.obj.SampleTime = sampleTime;\r\n    AFMSV2_Driver_Motor_Test_DW.obj.isInitialized = 1;\r\n\r\n    /*         %% Define output properties */\r\n    /* 'AFMSV2Driver:71' num = 4; */\r\n    /*         %% Define output properties */\r\n    /* 'AFMSV2Driver:71' num = 4; */\r\n    /*         %% Define output properties */\r\n    /* 'AFMSV2Driver:71' num = 4; */\r\n    /*         %% Define output properties */\r\n    /* 'AFMSV2Driver:71' num = 4; */\r\n    /*         %% Define output properties */\r\n    /* 'AFMSV2Driver:71' num = 4; */\r\n    /*         %% Define output properties */\r\n    /* 'AFMSV2Driver:71' num = 4; */\r\n    /* 'AFMSV2Driver:87' if isempty(coder.target) */\r\n    /* 'AFMSV2Driver:40' if isempty(coder.target) */\r\n    /* 'AFMSV2Driver:42' else */\r\n    /*  Call C-function implementing device initialization */\r\n    /* 'AFMSV2Driver:44' coder.cinclude('AFMSV2Driver.h'); */\r\n    /* 'AFMSV2Driver:45' coder.ceval('AFMSV2Driver_Init'); */\r\n    AFMSV2Driver_Init();\r\n    AFMSV2_Driver_Motor_Test_DW.obj.isSetupComplete = true;\r\n\r\n    /* End of Start for MATLABSystem: '<Root>/MATLAB System' */\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid AFMSV2_Driver_Motor_Test_terminate(void)\r\n{\r\n  /* Terminate for MATLABSystem: '<Root>/MATLAB System' */\r\n  if (!AFMSV2_Driver_Motor_Test_DW.obj.matlabCodegenIsDeleted) {\r\n    AFMSV2_Driver_Motor_Test_DW.obj.matlabCodegenIsDeleted = true;\r\n  }\r\n\r\n  /* End of Terminate for MATLABSystem: '<Root>/MATLAB System' */\r\n}\r\n"},{"name":"AFMSV2_Driver_Motor_Test.h","type":"header","group":"model","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * AFMSV2_Driver_Motor_Test.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_AFMSV2_Driver_Motor_Test_h_\r\n#define RTW_HEADER_AFMSV2_Driver_Motor_Test_h_\r\n#include <stddef.h>\r\n#include <string.h>\r\n#ifndef AFMSV2_Driver_Motor_Test_COMMON_INCLUDES_\r\n#define AFMSV2_Driver_Motor_Test_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"AFMSV2Driver.h\"\r\n#endif                           /* AFMSV2_Driver_Motor_Test_COMMON_INCLUDES_ */\r\n\r\n#include \"AFMSV2_Driver_Motor_Test_types.h\"\r\n#include \"MW_target_hardware_resources.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetInf.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  AFMSV2Driver_AFMSV2_Driver_Mo_T obj; /* '<Root>/MATLAB System' */\r\n} DW_AFMSV2_Driver_Motor_Test_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_AFMSV2_Driver_Motor_Test_T_ {\r\n  real_T MATLABSystem_SampleTime;      /* Expression: 0.1\r\n                                        * Referenced by: '<Root>/MATLAB System'\r\n                                        */\r\n  int16_T Constant_Value;              /* Computed Parameter: Constant_Value\r\n                                        * Referenced by: '<Root>/Constant'\r\n                                        */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_AFMSV2_Driver_Motor_T_T {\r\n  const char_T * volatile errorStatus;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_AFMSV2_Driver_Motor_Test_T AFMSV2_Driver_Motor_Test_P;\r\n\r\n/* Block states (default storage) */\r\nextern DW_AFMSV2_Driver_Motor_Test_T AFMSV2_Driver_Motor_Test_DW;\r\n\r\n/* Model entry point functions */\r\nextern void AFMSV2_Driver_Motor_Test_initialize(void);\r\nextern void AFMSV2_Driver_Motor_Test_step(void);\r\nextern void AFMSV2_Driver_Motor_Test_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_AFMSV2_Driver_Motor__T *const AFMSV2_Driver_Motor_Test_M;\r\nextern volatile boolean_T stopRequested;\r\nextern volatile boolean_T runModel;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'AFMSV2_Driver_Motor_Test'\r\n */\r\n#endif                              /* RTW_HEADER_AFMSV2_Driver_Motor_Test_h_ */\r\n"},{"name":"AFMSV2_Driver_Motor_Test_private.h","type":"header","group":"model","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * AFMSV2_Driver_Motor_Test_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_AFMSV2_Driver_Motor_Test_private_h_\r\n#define RTW_HEADER_AFMSV2_Driver_Motor_Test_private_h_\r\n#include \"rtwtypes.h\"\r\n#endif                      /* RTW_HEADER_AFMSV2_Driver_Motor_Test_private_h_ */\r\n"},{"name":"AFMSV2_Driver_Motor_Test_types.h","type":"header","group":"model","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * AFMSV2_Driver_Motor_Test_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_AFMSV2_Driver_Motor_Test_types_h_\r\n#define RTW_HEADER_AFMSV2_Driver_Motor_Test_types_h_\r\n#include \"rtwtypes.h\"\r\n\r\n/* Model Code Variants */\r\n#ifndef struct_tag_M7Rw3glXKl4piqm16w6jQG\r\n#define struct_tag_M7Rw3glXKl4piqm16w6jQG\r\n\r\nstruct tag_M7Rw3glXKl4piqm16w6jQG\r\n{\r\n  boolean_T matlabCodegenIsDeleted;\r\n  int32_T isInitialized;\r\n  boolean_T isSetupComplete;\r\n  real_T SampleTime;\r\n};\r\n\r\n#endif                                 /* struct_tag_M7Rw3glXKl4piqm16w6jQG */\r\n\r\n#ifndef typedef_AFMSV2Driver_AFMSV2_Driver_Mo_T\r\n#define typedef_AFMSV2Driver_AFMSV2_Driver_Mo_T\r\n\r\ntypedef struct tag_M7Rw3glXKl4piqm16w6jQG AFMSV2Driver_AFMSV2_Driver_Mo_T;\r\n\r\n#endif                             /* typedef_AFMSV2Driver_AFMSV2_Driver_Mo_T */\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_AFMSV2_Driver_Motor_Test_T_ P_AFMSV2_Driver_Motor_Test_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_AFMSV2_Driver_Motor_T_T RT_MODEL_AFMSV2_Driver_Motor__T;\r\n\r\n#endif                        /* RTW_HEADER_AFMSV2_Driver_Motor_Test_types_h_ */\r\n"},{"name":"AFMSV2_Driver_Motor_Test_data.c","type":"source","group":"data","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * AFMSV2_Driver_Motor_Test_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"AFMSV2_Driver_Motor_Test.h\"\r\n#include \"AFMSV2_Driver_Motor_Test_private.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_AFMSV2_Driver_Motor_Test_T AFMSV2_Driver_Motor_Test_P = {\r\n  /* Expression: 0.1\r\n   * Referenced by: '<Root>/MATLAB System'\r\n   */\r\n  0.1,\r\n\r\n  /* Computed Parameter: Constant_Value\r\n   * Referenced by: '<Root>/Constant'\r\n   */\r\n  0\r\n};\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, Inf\r\n */\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finite, NaN\r\n */\r\n#include \"rtGetNaN.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n/*\r\n * Abstract:\r\n *      Function to initialize non-finites,\r\n *      (Inf, NaN and -Inf).\r\n */\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Model version              : 1.3\r\n * Simulink Coder version : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: ARM Compatible->ARM Cortex\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: ARM Compatible->ARM Cortex\r\n *   Number of bits:     char:   8    short:   16    int:  32\r\n *                       long:  32\r\n *                       native word size:  32\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n * rtmodel.h\r\n *\r\n * Code generation for Simulink model \"AFMSV2_Driver_Motor_Test\".\r\n *\r\n * Simulink Coder version                : 9.6 (R2021b) 14-May-2021\r\n * C source code generated on : Tue Sep 13 14:44:14 2022\r\n *\r\n * Note that the generated code is not dependent on this header file.\r\n * The file is used in cojuction with the automatic build procedure.\r\n * It is included by the sample main executable harness\r\n * MATLAB/rtw/c/src/common/rt_main.c.\r\n *\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"AFMSV2_Driver_Motor_Test.h\"\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"AFMSV2Driver.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver\\src","tag":"","groupDisplay":"Other files","code":"//AFMSV2Driver.cpp\r\n#include <Arduino.h>\r\n#include <math.h>\r\n#include \"AFMSV2Driver.h\" \r\n#include \"Adafruit_MotorShield.h\"   \r\n\r\n/*Create object of the motor driver*/\r\nAdafruit_MotorShield AFMS = Adafruit_MotorShield();\r\nAdafruit_DCMotor *M1 = AFMS.getMotor(1);\r\nAdafruit_DCMotor *M2 = AFMS.getMotor(2);\r\nAdafruit_DCMotor *M3 = AFMS.getMotor(3);\r\nAdafruit_DCMotor *M4 = AFMS.getMotor(4);\r\n\r\nuint8_t init_f;\r\nextern \"C\" void AFMSV2Driver_Init(void)\r\n{ \r\n    // Initializing the device driver\r\n    if (!AFMS.begin()) init_f = 0; // Error, device not found\r\n    else init_f = 1; // Device found\r\n} \r\nextern \"C\" void AFMSV2Driver_Step(int16_t U1, int16_t U2, int16_t U3, int16_t U4) \r\n{ \r\n    if(init_f) {             /* If device is initialized properly, else return 0 */\r\n        if (U1 > 0) M1->run(FORWARD);\r\n        else if (U1 < 0) {\r\n            M1->run(BACKWARD);\r\n            U1 = fabs(U1);\r\n        } else M1->run(RELEASE);\r\n        if (U1 > 4095) U1 = 4095;\r\n\r\n        if (U2 > 0) M2->run(FORWARD);\r\n        else if (U2 < 0) {\r\n            M2->run(BACKWARD);\r\n            U2 = fabs(U2);\r\n        } else M2->run(RELEASE);\r\n        if (U2 > 4095) U2 = 4095;\r\n\r\n        if (U3 > 0) M3->run(FORWARD);\r\n        else if (U3 < 0) {\r\n            M3->run(BACKWARD);\r\n            U3 = fabs(U3);\r\n        } else M3->run(RELEASE);\r\n        if (U3 > 4095) U3 = 4095;\r\n\r\n        if (U4 > 0) M4->run(FORWARD);\r\n        else if (U4 < 0) {\r\n            M4->run(BACKWARD);\r\n            U4 = fabs(U4);\r\n        } else M4->run(RELEASE);\r\n        if (U4 > 4095) U4 = 4095;\r\n\r\n        M1->setSpeedFine((uint16_t) U1); // 0 (full off) to 4095 (full on)\r\n        M2->setSpeedFine((uint16_t) U2); // 0 (full off) to 4095 (full on)\r\n        M3->setSpeedFine((uint16_t) U3); // 0 (full off) to 4095 (full on)\r\n        M4->setSpeedFine((uint16_t) U4); // 0 (full off) to 4095 (full on)\r\n    } \r\n} \r\nextern \"C\" void AFMSV2Driver_Terminate() \r\n{ \r\n} "},{"name":"Adafruit_I2CDevice.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver\\libraries\\Adafruit_BusIO","tag":"","groupDisplay":"Other files","code":"#include \"Adafruit_I2CDevice.h\"\r\n\r\n//#define DEBUG_SERIAL Serial\r\n\r\n/*!\r\n *    @brief  Create an I2C device at a given address\r\n *    @param  addr The 7-bit I2C address for the device\r\n *    @param  theWire The I2C bus to use, defaults to &Wire\r\n */\r\nAdafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {\r\n  _addr = addr;\r\n  _wire = theWire;\r\n  _begun = false;\r\n#ifdef ARDUINO_ARCH_SAMD\r\n  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer\r\n#elif defined(ESP32)\r\n  _maxBufferSize = I2C_BUFFER_LENGTH;\r\n#else\r\n  _maxBufferSize = 32;\r\n#endif\r\n}\r\n\r\n/*!\r\n *    @brief  Initializes and does basic address detection\r\n *    @param  addr_detect Whether we should attempt to detect the I2C address\r\n * with a scan. 99% of sensors/devices don't mind but once in a while, they spaz\r\n * on a scan!\r\n *    @return True if I2C initialized and a device with the addr found\r\n */\r\nbool Adafruit_I2CDevice::begin(bool addr_detect) {\r\n  _wire->begin();\r\n  _begun = true;\r\n\r\n  if (addr_detect) {\r\n    return detected();\r\n  }\r\n  return true;\r\n}\r\n\r\n/*!\r\n *    @brief  De-initialize device, turn off the Wire interface\r\n */\r\nvoid Adafruit_I2CDevice::end(void) {\r\n  // Not all port implement Wire::end(), such as\r\n  // - ESP8266\r\n  // - AVR core without WIRE_HAS_END\r\n  // - ESP32: end() is implemented since 2.0.1 which is latest at the moment.\r\n  // Temporarily disable for now to give time for user to update.\r\n#if !(defined(ESP8266) ||                                                      \\\r\n      (defined(ARDUINO_ARCH_AVR) && !defined(WIRE_HAS_END)) ||                 \\\r\n      defined(ARDUINO_ARCH_ESP32))\r\n  _wire->end();\r\n  _begun = false;\r\n#endif\r\n}\r\n\r\n/*!\r\n *    @brief  Scans I2C for the address - note will give a false-positive\r\n *    if there's no pullups on I2C\r\n *    @return True if I2C initialized and a device with the addr found\r\n */\r\nbool Adafruit_I2CDevice::detected(void) {\r\n  // Init I2C if not done yet\r\n  if (!_begun && !begin()) {\r\n    return false;\r\n  }\r\n\r\n  // A basic scanner, see if it ACK's\r\n  _wire->beginTransmission(_addr);\r\n  if (_wire->endTransmission() == 0) {\r\n#ifdef DEBUG_SERIAL\r\n    DEBUG_SERIAL.println(F(\"Detected\"));\r\n#endif\r\n    return true;\r\n  }\r\n#ifdef DEBUG_SERIAL\r\n  DEBUG_SERIAL.println(F(\"Not detected\"));\r\n#endif\r\n  return false;\r\n}\r\n\r\n/*!\r\n *    @brief  Write a buffer or two to the I2C device. Cannot be more than\r\n * maxBufferSize() bytes.\r\n *    @param  buffer Pointer to buffer of data to write. This is const to\r\n *            ensure the content of this buffer doesn't change.\r\n *    @param  len Number of bytes from buffer to write\r\n *    @param  prefix_buffer Pointer to optional array of data to write before\r\n * buffer. Cannot be more than maxBufferSize() bytes. This is const to\r\n *            ensure the content of this buffer doesn't change.\r\n *    @param  prefix_len Number of bytes from prefix buffer to write\r\n *    @param  stop Whether to send an I2C STOP signal on write\r\n *    @return True if write was successful, otherwise false.\r\n */\r\nbool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,\r\n                               const uint8_t *prefix_buffer,\r\n                               size_t prefix_len) {\r\n  if ((len + prefix_len) > maxBufferSize()) {\r\n    // currently not guaranteed to work if more than 32 bytes!\r\n    // we will need to find out if some platforms have larger\r\n    // I2C buffer sizes :/\r\n#ifdef DEBUG_SERIAL\r\n    DEBUG_SERIAL.println(F(\"\\tI2CDevice could not write such a large buffer\"));\r\n#endif\r\n    return false;\r\n  }\r\n\r\n  _wire->beginTransmission(_addr);\r\n\r\n  // Write the prefix data (usually an address)\r\n  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {\r\n    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {\r\n#ifdef DEBUG_SERIAL\r\n      DEBUG_SERIAL.println(F(\"\\tI2CDevice failed to write\"));\r\n#endif\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Write the data itself\r\n  if (_wire->write(buffer, len) != len) {\r\n#ifdef DEBUG_SERIAL\r\n    DEBUG_SERIAL.println(F(\"\\tI2CDevice failed to write\"));\r\n#endif\r\n    return false;\r\n  }\r\n\r\n#ifdef DEBUG_SERIAL\r\n\r\n  DEBUG_SERIAL.print(F(\"\\tI2CWRITE @ 0x\"));\r\n  DEBUG_SERIAL.print(_addr, HEX);\r\n  DEBUG_SERIAL.print(F(\" :: \"));\r\n  if ((prefix_len != 0) && (prefix_buffer != nullptr)) {\r\n    for (uint16_t i = 0; i < prefix_len; i++) {\r\n      DEBUG_SERIAL.print(F(\"0x\"));\r\n      DEBUG_SERIAL.print(prefix_buffer[i], HEX);\r\n      DEBUG_SERIAL.print(F(\", \"));\r\n    }\r\n  }\r\n  for (uint16_t i = 0; i < len; i++) {\r\n    DEBUG_SERIAL.print(F(\"0x\"));\r\n    DEBUG_SERIAL.print(buffer[i], HEX);\r\n    DEBUG_SERIAL.print(F(\", \"));\r\n    if (i % 32 == 31) {\r\n      DEBUG_SERIAL.println();\r\n    }\r\n  }\r\n\r\n  if (stop) {\r\n    DEBUG_SERIAL.print(\"\\tSTOP\");\r\n  }\r\n#endif\r\n\r\n  if (_wire->endTransmission(stop) == 0) {\r\n#ifdef DEBUG_SERIAL\r\n    DEBUG_SERIAL.println();\r\n    // DEBUG_SERIAL.println(\"Sent!\");\r\n#endif\r\n    return true;\r\n  } else {\r\n#ifdef DEBUG_SERIAL\r\n    DEBUG_SERIAL.println(\"\\tFailed to send!\");\r\n#endif\r\n    return false;\r\n  }\r\n}\r\n\r\n/*!\r\n *    @brief  Read from I2C into a buffer from the I2C device.\r\n *    Cannot be more than maxBufferSize() bytes.\r\n *    @param  buffer Pointer to buffer of data to read into\r\n *    @param  len Number of bytes from buffer to read.\r\n *    @param  stop Whether to send an I2C STOP signal on read\r\n *    @return True if read was successful, otherwise false.\r\n */\r\nbool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {\r\n  size_t pos = 0;\r\n  while (pos < len) {\r\n    size_t read_len =\r\n        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);\r\n    bool read_stop = (pos < (len - read_len)) ? false : stop;\r\n    if (!_read(buffer + pos, read_len, read_stop))\r\n      return false;\r\n    pos += read_len;\r\n  }\r\n  return true;\r\n}\r\n\r\nbool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {\r\n#if defined(TinyWireM_h)\r\n  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);\r\n#elif defined(ARDUINO_ARCH_MEGAAVR)\r\n  size_t recv = _wire->requestFrom(_addr, len, stop);\r\n#else\r\n  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);\r\n#endif\r\n\r\n  if (recv != len) {\r\n    // Not enough data available to fulfill our obligation!\r\n#ifdef DEBUG_SERIAL\r\n    DEBUG_SERIAL.print(F(\"\\tI2CDevice did not receive enough data: \"));\r\n    DEBUG_SERIAL.println(recv);\r\n#endif\r\n    return false;\r\n  }\r\n\r\n  for (uint16_t i = 0; i < len; i++) {\r\n    buffer[i] = _wire->read();\r\n  }\r\n\r\n#ifdef DEBUG_SERIAL\r\n  DEBUG_SERIAL.print(F(\"\\tI2CREAD  @ 0x\"));\r\n  DEBUG_SERIAL.print(_addr, HEX);\r\n  DEBUG_SERIAL.print(F(\" :: \"));\r\n  for (uint16_t i = 0; i < len; i++) {\r\n    DEBUG_SERIAL.print(F(\"0x\"));\r\n    DEBUG_SERIAL.print(buffer[i], HEX);\r\n    DEBUG_SERIAL.print(F(\", \"));\r\n    if (len % 32 == 31) {\r\n      DEBUG_SERIAL.println();\r\n    }\r\n  }\r\n  DEBUG_SERIAL.println();\r\n#endif\r\n\r\n  return true;\r\n}\r\n\r\n/*!\r\n *    @brief  Write some data, then read some data from I2C into another buffer.\r\n *    Cannot be more than maxBufferSize() bytes. The buffers can point to\r\n *    same/overlapping locations.\r\n *    @param  write_buffer Pointer to buffer of data to write from\r\n *    @param  write_len Number of bytes from buffer to write.\r\n *    @param  read_buffer Pointer to buffer of data to read into.\r\n *    @param  read_len Number of bytes from buffer to read.\r\n *    @param  stop Whether to send an I2C STOP signal between the write and read\r\n *    @return True if write & read was successful, otherwise false.\r\n */\r\nbool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,\r\n                                         size_t write_len, uint8_t *read_buffer,\r\n                                         size_t read_len, bool stop) {\r\n  if (!write(write_buffer, write_len, stop)) {\r\n    return false;\r\n  }\r\n\r\n  return read(read_buffer, read_len);\r\n}\r\n\r\n/*!\r\n *    @brief  Returns the 7-bit address of this device\r\n *    @return The 7-bit address of this device\r\n */\r\nuint8_t Adafruit_I2CDevice::address(void) { return _addr; }\r\n\r\n/*!\r\n *    @brief  Change the I2C clock speed to desired (relies on\r\n *    underlying Wire support!\r\n *    @param desiredclk The desired I2C SCL frequency\r\n *    @return True if this platform supports changing I2C speed.\r\n *    Not necessarily that the speed was achieved!\r\n */\r\nbool Adafruit_I2CDevice::setSpeed(uint32_t desiredclk) {\r\n#if defined(__AVR_ATmega328__) ||                                              \\\r\n    defined(__AVR_ATmega328P__) // fix arduino core set clock\r\n  // calculate TWBR correctly\r\n\r\n  if ((F_CPU / 18) < desiredclk) {\r\n#ifdef DEBUG_SERIAL\r\n    Serial.println(F(\"I2C.setSpeed too high.\"));\r\n#endif\r\n    return false;\r\n  }\r\n  uint32_t atwbr = ((F_CPU / desiredclk) - 16) / 2;\r\n  if (atwbr > 16320) {\r\n#ifdef DEBUG_SERIAL\r\n    Serial.println(F(\"I2C.setSpeed too low.\"));\r\n#endif\r\n    return false;\r\n  }\r\n\r\n  if (atwbr <= 255) {\r\n    atwbr /= 1;\r\n    TWSR = 0x0;\r\n  } else if (atwbr <= 1020) {\r\n    atwbr /= 4;\r\n    TWSR = 0x1;\r\n  } else if (atwbr <= 4080) {\r\n    atwbr /= 16;\r\n    TWSR = 0x2;\r\n  } else { //  if (atwbr <= 16320)\r\n    atwbr /= 64;\r\n    TWSR = 0x3;\r\n  }\r\n  TWBR = atwbr;\r\n\r\n#ifdef DEBUG_SERIAL\r\n  Serial.print(F(\"TWSR prescaler = \"));\r\n  Serial.println(pow(4, TWSR));\r\n  Serial.print(F(\"TWBR = \"));\r\n  Serial.println(atwbr);\r\n#endif\r\n  return true;\r\n#elif (ARDUINO >= 157) && !defined(ARDUINO_STM32_FEATHER) &&                   \\\r\n    !defined(TinyWireM_h)\r\n  _wire->setClock(desiredclk);\r\n  return true;\r\n\r\n#else\r\n  (void)desiredclk;\r\n  return false;\r\n#endif\r\n}\r\n"},{"name":"Adafruit_MS_PWMServoDriver.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver\\libraries\\Adafruit_Motor_Shield_V2_Library\\utility","tag":"","groupDisplay":"Other files","code":"/***************************************************\r\n  This is a library for our Adafruit 16-channel PWM & Servo driver\r\n\r\n  Pick one up today in the adafruit shop!\r\n  ------> http://www.adafruit.com/products/815\r\n\r\n  These displays use I2C to communicate, 2 pins are required to\r\n  interface. For Arduino UNOs, thats SCL -> Analog 5, SDA -> Analog 4\r\n\r\n  Adafruit invests time and resources providing this open source code,\r\n  please support Adafruit and open-source hardware by purchasing\r\n  products from Adafruit!\r\n\r\n  Written by Limor Fried/Ladyada for Adafruit Industries.\r\n  BSD license, all text above must be included in any redistribution\r\n ****************************************************/\r\n\r\n#include <Adafruit_MS_PWMServoDriver.h>\r\n\r\nAdafruit_MS_PWMServoDriver::Adafruit_MS_PWMServoDriver(uint8_t addr) {\r\n  _i2caddr = addr;\r\n}\r\n\r\nbool Adafruit_MS_PWMServoDriver::begin(TwoWire *theWire) {\r\n  if (i2c_dev)\r\n    delete i2c_dev;\r\n  i2c_dev = new Adafruit_I2CDevice(_i2caddr, theWire);\r\n  if (!i2c_dev->begin())\r\n    return false;\r\n  reset();\r\n  return true;\r\n}\r\n\r\nvoid Adafruit_MS_PWMServoDriver::reset(void) { write8(PCA9685_MODE1, 0x0); }\r\n\r\nvoid Adafruit_MS_PWMServoDriver::setPWMFreq(float freq) {\r\n  // Serial.print(\"Attempting to set freq \");\r\n  // Serial.println(freq);\r\n\r\n  freq *=\r\n      0.9; // Correct for overshoot in the frequency setting (see issue #11).\r\n\r\n  float prescaleval = 25000000;\r\n  prescaleval /= 4096;\r\n  prescaleval /= freq;\r\n  prescaleval -= 1;\r\n  // Serial.print(\"Estimated pre-scale: \"); Serial.println(prescaleval);\r\n  uint8_t prescale = floor(prescaleval + 0.5);\r\n  // Serial.print(\"Final pre-scale: \"); Serial.println(prescale);\r\n\r\n  uint8_t oldmode = read8(PCA9685_MODE1);\r\n  uint8_t newmode = (oldmode & 0x7F) | 0x10; // sleep\r\n  write8(PCA9685_MODE1, newmode);            // go to sleep\r\n  write8(PCA9685_PRESCALE, prescale);        // set the prescaler\r\n  write8(PCA9685_MODE1, oldmode);\r\n  delay(5);\r\n  write8(PCA9685_MODE1,\r\n         oldmode |\r\n             0xa1); //  This sets the MODE1 register to turn on auto increment.\r\n                    // This is why the beginTransmission below was not working.\r\n  //  Serial.print(\"Mode now 0x\"); Serial.println(read8(PCA9685_MODE1), HEX);\r\n}\r\n\r\nvoid Adafruit_MS_PWMServoDriver::setPWM(uint8_t num, uint16_t on,\r\n                                        uint16_t off) {\r\n  // Serial.print(\"Setting PWM \"); Serial.print(num); Serial.print(\": \");\r\n  // Serial.print(on); Serial.print(\"->\"); Serial.println(off);\r\n  uint8_t buffer[5];\r\n  buffer[0] = LED0_ON_L + 4 * num;\r\n  buffer[1] = on;\r\n  buffer[2] = on >> 8;\r\n  buffer[3] = off;\r\n  buffer[4] = off >> 8;\r\n  i2c_dev->write(buffer, 5);\r\n}\r\n\r\nuint8_t Adafruit_MS_PWMServoDriver::read8(uint8_t addr) {\r\n  uint8_t buffer[1] = {addr};\r\n  i2c_dev->write_then_read(buffer, 1, buffer, 1);\r\n  return buffer[0];\r\n}\r\n\r\nvoid Adafruit_MS_PWMServoDriver::write8(uint8_t addr, uint8_t d) {\r\n  uint8_t buffer[2] = {addr, d};\r\n  i2c_dev->write(buffer, 2);\r\n}\r\n"},{"name":"Adafruit_MotorShield.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver\\libraries\\Adafruit_Motor_Shield_V2_Library","tag":"","groupDisplay":"Other files","code":"/*!\r\n * @file Adafruit_MotorShield.cpp\r\n *\r\n * @mainpage Adafruit FXOS8700 accel/mag sensor driver\r\n *\r\n * @section intro_sec Introduction\r\n *\r\n * This is the library for the Adafruit Motor Shield V2 for Arduino.\r\n * It supports DC motors & Stepper motors with microstepping as well\r\n * as stacking-support. It is *not* compatible with the V1 library!\r\n * For use with the Motor Shield https://www.adafruit.com/products/1483\r\n * and Motor FeatherWing https://www.adafruit.com/product/2927\r\n *\r\n * This shield/wing uses I2C to communicate, 2 pins (SCL+SDA) are required\r\n * to interface.\r\n *\r\n * Adafruit invests time and resources providing this open source code,\r\n * please support Adafruit and open-source hardware by purchasing\r\n * products from Adafruit!\r\n *\r\n * @section author Author\r\n *\r\n * Written by Limor Fried/Ladyada for Adafruit Industries.\r\n *\r\n * @section license License\r\n *\r\n * BSD license, all text here must be included in any redistribution.\r\n *\r\n */\r\n\r\n#include \"Adafruit_MotorShield.h\"\r\n#include \"Arduino.h\"\r\n#include <Adafruit_MS_PWMServoDriver.h>\r\n\r\n#if (MICROSTEPS == 8)\r\n///! A sinusoial microstepping curve for the PWM output (8-bit range) with 9\r\n/// points - last one is start of next step.\r\nstatic uint8_t microstepcurve[] = {0, 50, 98, 142, 180, 212, 236, 250, 255};\r\n#elif (MICROSTEPS == 16)\r\n///! A sinusoial microstepping curve for the PWM output (8-bit range) with 17\r\n/// points - last one is start of next step.\r\nstatic uint8_t microstepcurve[] = {0,   25,  50,  74,  98,  120, 141, 162, 180,\r\n                                   197, 212, 225, 236, 244, 250, 253, 255};\r\n#endif\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Create the Motor Shield object at an I2C address, default is 0x60\r\n    @param  addr Optional I2C address if you've changed it\r\n*/\r\n/**************************************************************************/\r\nAdafruit_MotorShield::Adafruit_MotorShield(uint8_t addr) { _addr = addr; }\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Initialize the I2C hardware and PWM driver, then turn off all pins.\r\n    @param    freq\r\n    The PWM frequency for the driver, used for speed control and microstepping.\r\n    By default we use 1600 Hz which is a little audible but efficient.\r\n    @param    theWire\r\n    A pointer to an optional I2C interface. If not provided, we use Wire or\r\n   Wire1 (on Due)\r\n    @returns true if successful, false otherwise\r\n*/\r\n/**************************************************************************/\r\nbool Adafruit_MotorShield::begin(uint16_t freq, TwoWire *theWire) {\r\n  // init PWM w/_freq\r\n  _pwm = Adafruit_MS_PWMServoDriver(_addr);\r\n  if (!_pwm.begin(theWire))\r\n    return false;\r\n  _freq = freq;\r\n  _pwm.setPWMFreq(_freq); // This is the maximum PWM frequency\r\n  for (uint8_t i = 0; i < 16; i++)\r\n    _pwm.setPWM(i, 0, 0);\r\n  return true;\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Helper that sets the PWM output on a pin and manages 'all on or off'\r\n    @param  pin The PWM output on the driver that we want to control (0-15)\r\n    @param  value The 12-bit PWM value we want to set (0-4095) - 4096 is a\r\n   special 'all on' value\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_MotorShield::setPWM(uint8_t pin, uint16_t value) {\r\n  if (value > 4095) {\r\n    _pwm.setPWM(pin, 4096, 0);\r\n  } else\r\n    _pwm.setPWM(pin, 0, value);\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Helper that sets the PWM output on a pin as if it were a GPIO\r\n    @param  pin The PWM output on the driver that we want to control (0-15)\r\n    @param  value HIGH or LOW depending on the value you want!\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_MotorShield::setPin(uint8_t pin, boolean value) {\r\n  if (value == LOW)\r\n    _pwm.setPWM(pin, 0, 0);\r\n  else\r\n    _pwm.setPWM(pin, 4096, 0);\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Mini factory that will return a pointer to an already-allocated\r\n    Adafruit_DCMotor object. Initializes the DC motor and turns off all pins\r\n    @param  num The DC motor port we want to use: 1 thru 4 are valid\r\n    @returns NULL if something went wrong, or a pointer to a Adafruit_DCMotor\r\n*/\r\n/**************************************************************************/\r\nAdafruit_DCMotor *Adafruit_MotorShield::getMotor(uint8_t num) {\r\n  if (num > 4)\r\n    return NULL;\r\n\r\n  num--;\r\n\r\n  if (dcmotors[num].motornum == 0) {\r\n    // not init'd yet!\r\n    dcmotors[num].motornum = num;\r\n    dcmotors[num].MC = this;\r\n    uint8_t pwm, in1, in2;\r\n    if (num == 0) {\r\n      pwm = 8;\r\n      in2 = 9;\r\n      in1 = 10;\r\n    } else if (num == 1) {\r\n      pwm = 13;\r\n      in2 = 12;\r\n      in1 = 11;\r\n    } else if (num == 2) {\r\n      pwm = 2;\r\n      in2 = 3;\r\n      in1 = 4;\r\n    } else if (num == 3) {\r\n      pwm = 7;\r\n      in2 = 6;\r\n      in1 = 5;\r\n    }\r\n    dcmotors[num].PWMpin = pwm;\r\n    dcmotors[num].IN1pin = in1;\r\n    dcmotors[num].IN2pin = in2;\r\n  }\r\n  return &dcmotors[num];\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Mini factory that will return a pointer to an already-allocated\r\n    Adafruit_StepperMotor object with a given 'steps per rotation.\r\n    Then initializes the stepper motor and turns off all pins.\r\n    @param  steps How many steps per revolution (used for RPM calculation)\r\n    @param  num The stepper motor port we want to use: only 1 or 2 are valid\r\n    @returns NULL if something went wrong, or a pointer to a\r\n   Adafruit_StepperMotor\r\n*/\r\n/**************************************************************************/\r\nAdafruit_StepperMotor *Adafruit_MotorShield::getStepper(uint16_t steps,\r\n                                                        uint8_t num) {\r\n  if (num > 2)\r\n    return NULL;\r\n\r\n  num--;\r\n\r\n  if (steppers[num].steppernum == 0) {\r\n    // not init'd yet!\r\n    steppers[num].steppernum = num;\r\n    steppers[num].revsteps = steps;\r\n    steppers[num].MC = this;\r\n    uint8_t pwma, pwmb, ain1, ain2, bin1, bin2;\r\n    if (num == 0) {\r\n      pwma = 8;\r\n      ain2 = 9;\r\n      ain1 = 10;\r\n      pwmb = 13;\r\n      bin2 = 12;\r\n      bin1 = 11;\r\n    } else if (num == 1) {\r\n      pwma = 2;\r\n      ain2 = 3;\r\n      ain1 = 4;\r\n      pwmb = 7;\r\n      bin2 = 6;\r\n      bin1 = 5;\r\n    }\r\n    steppers[num].PWMApin = pwma;\r\n    steppers[num].PWMBpin = pwmb;\r\n    steppers[num].AIN1pin = ain1;\r\n    steppers[num].AIN2pin = ain2;\r\n    steppers[num].BIN1pin = bin1;\r\n    steppers[num].BIN2pin = bin2;\r\n  }\r\n  return &steppers[num];\r\n}\r\n\r\n/******************************************\r\n               MOTORS\r\n******************************************/\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Create a DCMotor object, un-initialized!\r\n    You should never call this, instead have the {@link Adafruit_MotorShield}\r\n    give you a DCMotor object with {@link Adafruit_MotorShield.getMotor}\r\n*/\r\n/**************************************************************************/\r\nAdafruit_DCMotor::Adafruit_DCMotor(void) {\r\n  MC = NULL;\r\n  motornum = 0;\r\n  PWMpin = IN1pin = IN2pin = 0;\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Control the DC Motor direction and action\r\n    @param  cmd The action to perform, can be FORWARD, BACKWARD or RELEASE\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_DCMotor::run(uint8_t cmd) {\r\n  switch (cmd) {\r\n  case FORWARD:\r\n    MC->setPin(IN2pin, LOW); // take low first to avoid 'break'\r\n    MC->setPin(IN1pin, HIGH);\r\n    break;\r\n  case BACKWARD:\r\n    MC->setPin(IN1pin, LOW); // take low first to avoid 'break'\r\n    MC->setPin(IN2pin, HIGH);\r\n    break;\r\n  case RELEASE:\r\n    MC->setPin(IN1pin, LOW);\r\n    MC->setPin(IN2pin, LOW);\r\n    break;\r\n  }\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Control the DC Motor speed/throttle\r\n    @param  speed The 8-bit PWM value, 0 is off, 255 is on\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_DCMotor::setSpeed(uint8_t speed) {\r\n  MC->setPWM(PWMpin, speed * 16);\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Control the DC Motor speed/throttle with 12 bit resolution.\r\n    @param  speed The 12-bit PWM value, 0 (full off) to 4095 (full on)\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_DCMotor::setSpeedFine(uint16_t speed) {\r\n  MC->setPWM(PWMpin, speed > 4095 ? 4095 : speed);\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Set DC motor to full on.\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_DCMotor::fullOn() { MC->_pwm.setPWM(PWMpin, 4096, 0); }\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Set DC motor to full off.\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_DCMotor::fullOff() { MC->_pwm.setPWM(PWMpin, 0, 4096); }\r\n\r\n/******************************************\r\n               STEPPERS\r\n******************************************/\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Create a StepperMotor object, un-initialized!\r\n    You should never call this, instead have the {@link Adafruit_MotorShield}\r\n    give you a StepperMotor object with {@link Adafruit_MotorShield.getStepper}\r\n*/\r\n/**************************************************************************/\r\nAdafruit_StepperMotor::Adafruit_StepperMotor(void) {\r\n  revsteps = steppernum = currentstep = 0;\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Set the delay for the Stepper Motor speed in RPM\r\n    @param  rpm The desired RPM, we will do our best to reach it!\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_StepperMotor::setSpeed(uint16_t rpm) {\r\n  // Serial.println(\"steps per rev: \"); Serial.println(revsteps);\r\n  // Serial.println(\"RPM: \"); Serial.println(rpm);\r\n\r\n  usperstep = 60000000 / ((uint32_t)revsteps * (uint32_t)rpm);\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Release all pins of the stepper motor so it free-spins\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_StepperMotor::release(void) {\r\n  MC->setPin(AIN1pin, LOW);\r\n  MC->setPin(AIN2pin, LOW);\r\n  MC->setPin(BIN1pin, LOW);\r\n  MC->setPin(BIN2pin, LOW);\r\n  MC->setPWM(PWMApin, 0);\r\n  MC->setPWM(PWMBpin, 0);\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Move the stepper motor with the given RPM speed, don't forget to\r\n   call\r\n    {@link Adafruit_StepperMotor.setSpeed} to set the speed!\r\n    @param  steps The number of steps we want to move\r\n    @param  dir The direction to go, can be FORWARD or BACKWARD\r\n    @param  style How to perform each step, can be SINGLE, DOUBLE, INTERLEAVE or\r\n   MICROSTEP\r\n*/\r\n/**************************************************************************/\r\nvoid Adafruit_StepperMotor::step(uint16_t steps, uint8_t dir, uint8_t style) {\r\n  uint32_t uspers = usperstep;\r\n\r\n  if (style == INTERLEAVE) {\r\n    uspers /= 2;\r\n  } else if (style == MICROSTEP) {\r\n    uspers /= MICROSTEPS;\r\n    steps *= MICROSTEPS;\r\n#ifdef MOTORDEBUG\r\n    Serial.print(\"steps = \");\r\n    Serial.println(steps, DEC);\r\n#endif\r\n  }\r\n\r\n  while (steps--) {\r\n    // Serial.println(\"step!\"); Serial.println(uspers);\r\n    onestep(dir, style);\r\n    delayMicroseconds(uspers);\r\n#ifdef ESP8266\r\n    yield(); // required for ESP8266\r\n#endif\r\n  }\r\n}\r\n\r\n/**************************************************************************/\r\n/*!\r\n    @brief  Move the stepper motor one step only, with no delays\r\n    @param  dir The direction to go, can be FORWARD or BACKWARD\r\n    @param  style How to perform each step, can be SINGLE, DOUBLE, INTERLEAVE or\r\n   MICROSTEP\r\n    @returns The current step/microstep index, useful for\r\n   Adafruit_StepperMotor.step to keep track of the current location, especially\r\n   when microstepping\r\n*/\r\n/**************************************************************************/\r\nuint8_t Adafruit_StepperMotor::onestep(uint8_t dir, uint8_t style) {\r\n  uint8_t ocrb, ocra;\r\n\r\n  ocra = ocrb = 255;\r\n\r\n  // next determine what sort of stepping procedure we're up to\r\n  if (style == SINGLE) {\r\n    if ((currentstep / (MICROSTEPS / 2)) % 2) { // we're at an odd step, weird\r\n      if (dir == FORWARD) {\r\n        currentstep += MICROSTEPS / 2;\r\n      } else {\r\n        currentstep -= MICROSTEPS / 2;\r\n      }\r\n    } else { // go to the next even step\r\n      if (dir == FORWARD) {\r\n        currentstep += MICROSTEPS;\r\n      } else {\r\n        currentstep -= MICROSTEPS;\r\n      }\r\n    }\r\n  } else if (style == DOUBLE) {\r\n    if (!(currentstep / (MICROSTEPS / 2) % 2)) { // we're at an even step, weird\r\n      if (dir == FORWARD) {\r\n        currentstep += MICROSTEPS / 2;\r\n      } else {\r\n        currentstep -= MICROSTEPS / 2;\r\n      }\r\n    } else { // go to the next odd step\r\n      if (dir == FORWARD) {\r\n        currentstep += MICROSTEPS;\r\n      } else {\r\n        currentstep -= MICROSTEPS;\r\n      }\r\n    }\r\n  } else if (style == INTERLEAVE) {\r\n    if (dir == FORWARD) {\r\n      currentstep += MICROSTEPS / 2;\r\n    } else {\r\n      currentstep -= MICROSTEPS / 2;\r\n    }\r\n  }\r\n\r\n  if (style == MICROSTEP) {\r\n    if (dir == FORWARD) {\r\n      currentstep++;\r\n    } else {\r\n      // BACKWARDS\r\n      currentstep--;\r\n    }\r\n\r\n    currentstep += MICROSTEPS * 4;\r\n    currentstep %= MICROSTEPS * 4;\r\n\r\n    ocra = ocrb = 0;\r\n    if (currentstep < MICROSTEPS) {\r\n      ocra = microstepcurve[MICROSTEPS - currentstep];\r\n      ocrb = microstepcurve[currentstep];\r\n    } else if ((currentstep >= MICROSTEPS) && (currentstep < MICROSTEPS * 2)) {\r\n      ocra = microstepcurve[currentstep - MICROSTEPS];\r\n      ocrb = microstepcurve[MICROSTEPS * 2 - currentstep];\r\n    } else if ((currentstep >= MICROSTEPS * 2) &&\r\n               (currentstep < MICROSTEPS * 3)) {\r\n      ocra = microstepcurve[MICROSTEPS * 3 - currentstep];\r\n      ocrb = microstepcurve[currentstep - MICROSTEPS * 2];\r\n    } else if ((currentstep >= MICROSTEPS * 3) &&\r\n               (currentstep < MICROSTEPS * 4)) {\r\n      ocra = microstepcurve[currentstep - MICROSTEPS * 3];\r\n      ocrb = microstepcurve[MICROSTEPS * 4 - currentstep];\r\n    }\r\n  }\r\n\r\n  currentstep += MICROSTEPS * 4;\r\n  currentstep %= MICROSTEPS * 4;\r\n\r\n#ifdef MOTORDEBUG\r\n  Serial.print(\"current step: \");\r\n  Serial.println(currentstep, DEC);\r\n  Serial.print(\" pwmA = \");\r\n  Serial.print(ocra, DEC);\r\n  Serial.print(\" pwmB = \");\r\n  Serial.println(ocrb, DEC);\r\n#endif\r\n  MC->setPWM(PWMApin, ocra * 16);\r\n  MC->setPWM(PWMBpin, ocrb * 16);\r\n\r\n  // release all\r\n  uint8_t latch_state = 0; // all motor pins to 0\r\n\r\n  // Serial.println(step, DEC);\r\n  if (style == MICROSTEP) {\r\n    if (currentstep < MICROSTEPS)\r\n      latch_state |= 0x03;\r\n    if ((currentstep >= MICROSTEPS) && (currentstep < MICROSTEPS * 2))\r\n      latch_state |= 0x06;\r\n    if ((currentstep >= MICROSTEPS * 2) && (currentstep < MICROSTEPS * 3))\r\n      latch_state |= 0x0C;\r\n    if ((currentstep >= MICROSTEPS * 3) && (currentstep < MICROSTEPS * 4))\r\n      latch_state |= 0x09;\r\n  } else {\r\n    switch (currentstep / (MICROSTEPS / 2)) {\r\n    case 0:\r\n      latch_state |= 0x1; // energize coil 1 only\r\n      break;\r\n    case 1:\r\n      latch_state |= 0x3; // energize coil 1+2\r\n      break;\r\n    case 2:\r\n      latch_state |= 0x2; // energize coil 2 only\r\n      break;\r\n    case 3:\r\n      latch_state |= 0x6; // energize coil 2+3\r\n      break;\r\n    case 4:\r\n      latch_state |= 0x4; // energize coil 3 only\r\n      break;\r\n    case 5:\r\n      latch_state |= 0xC; // energize coil 3+4\r\n      break;\r\n    case 6:\r\n      latch_state |= 0x8; // energize coil 4 only\r\n      break;\r\n    case 7:\r\n      latch_state |= 0x9; // energize coil 1+4\r\n      break;\r\n    }\r\n  }\r\n#ifdef MOTORDEBUG\r\n  Serial.print(\"Latch: 0x\");\r\n  Serial.println(latch_state, HEX);\r\n#endif\r\n\r\n  if (latch_state & 0x1) {\r\n    // Serial.println(AIN2pin);\r\n    MC->setPin(AIN2pin, HIGH);\r\n  } else {\r\n    MC->setPin(AIN2pin, LOW);\r\n  }\r\n  if (latch_state & 0x2) {\r\n    MC->setPin(BIN1pin, HIGH);\r\n    // Serial.println(BIN1pin);\r\n  } else {\r\n    MC->setPin(BIN1pin, LOW);\r\n  }\r\n  if (latch_state & 0x4) {\r\n    MC->setPin(AIN1pin, HIGH);\r\n    // Serial.println(AIN1pin);\r\n  } else {\r\n    MC->setPin(AIN1pin, LOW);\r\n  }\r\n  if (latch_state & 0x8) {\r\n    MC->setPin(BIN2pin, HIGH);\r\n    // Serial.println(BIN2pin);\r\n  } else {\r\n    MC->setPin(BIN2pin, LOW);\r\n  }\r\n\r\n  return currentstep;\r\n}\r\n"},{"name":"MW_ArduinoHWInit.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\arduinotarget\\registry\\..\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n *\n * Copyright 2014-2020 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"io_wrappers.h\"\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#include \"arduinoARM_M0plusScheduler.h\"\n#elif defined(ARDUINO_ARM_CORTEX_M3)\n#include \"arduinoARMScheduler.h\"\n#include \"watchdog.h\"\n#else\n#include \"arduinoAVRScheduler.h\"\n#endif\n\n#ifdef _RTT_NUMI2C_\n#include \"MW_arduinoI2C.h\"\n#endif\n\n#if defined(ARDUINO_ARDUINO_NANO33BLE)\n    #include \"MW_PWM_NANO33BLE.h\"\n#endif\n\n#if (defined(_RTT_SPI_SSPIN_)) || (defined(_RTT_DUE_SPI_SSPIN4_)) || (defined(_RTT_DUE_SPI_SSPIN10_)) || (defined(_RTT_DUE_SPI_SSPIN52_))\n#include \"MW_SPIwriteRead.h\"\n#endif\n\n#if (defined(_RTT_RS485_INUSE_))\n#include \"ArduinoRS485.h\"\n#endif\n\n#if (defined(_RTT_MODBUS_MASTER_)) || (defined(_RTT_MODBUS_SLAVE_))\n#include \"ArduinoModbus.h\"\n#endif\n\n#ifdef NANO_MOTOR_CARRIER\n#include <Wire.h>\n#define PMIC_ADDRESS  0x6B\n#define PMIC_REG00    0x00\n#define PMIC_REG01    0x01\n#define PMIC_REG02    0x02\n#define PMIC_REG04    0x04\n#define PMIC_REG05    0x05\nvoid MW_EnableNanoCarrierBatteryCharging(void);\n#endif\n\n// Wifi init routines\n#include <inttypes.h>\n#if (defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)) || (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_)\n    #if defined(ARDUINO_WIFI_LIB_101)\n        #include <WiFi101.h>\n    #elif defined(ARDUINO_WIFI_LIB_NINA)\n        #include <WiFiNINA.h>\n    #else\n        #include <WiFi.h>\n    #endif\n    #include <SPI.h>\n\n    /*#define that helps to stringify build flags\n    //Double evaluation is needed so that the double quotes can be derived out\n    //of the build flag and can be assigned to a character array */\n    #define RTT_StringifyBuildFlag(x) RTT_StringParamExpanded(x)\n    #define RTT_StringParamExpanded(x)  #x \n\n    IPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\n    char ssid[] = RTT_StringifyBuildFlag(_RTT_WIFI_SSID);\n    int configureSuccess = WL_IDLE_STATUS;\n    int trialcount;\n\n    #ifdef _RTT_WIFI_WEP\n        char key[] = RTT_StringifyBuildFlag(_RTT_WIFI_KEY);\n        int keyIndex = _RTT_WIFI_KEY_INDEX;\n    #endif //_RTT_WIFI_WEP\n\n    #ifdef _RTT_WIFI_WPA\n        char wpapass[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA_PASSWORD);\n    #endif //_RTT_WIFI_WPA\n        \n#endif //(defined(_RTT_THINGSPEAK_WIFI_) || (_RTT_WIFI_TCP_ !=0) || defined(_RTT_WEBSOCKET_PORT_))\n\n#include \"MW_ArduinoHWInit.h\"\n#ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n#include \"MW_graphicPrimitive.h\"\n#endif\n\n\n  \nvoid MW_Modbus_Slave_Poll(void)\n{\n    #if defined(_RTT_MODBUS_SLAVE_)\n    ModbusRTUServer.poll();\n    #endif\n}\n\nvoid MW_ArduinoNano33BLESenseInit(void)\n{\n  #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    initVariant();    \n    #if defined(SERIAL_CDC)\n       PluggableUSBD().begin();\n       SerialUSB.begin(115200);\n    #endif  \n    #if defined(_RTT_PWM_NANO33BLE_INUSE)\n        MW_NANO33BLE_PWM_Setup();\n    #endif\n #endif\n}\n\nvoid MW_Arduino_Init(void)\n{\n    //Hardware specific init for Arduino nano 33 ble sense\n#if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    MW_ArduinoNano33BLESenseInit();\n#endif\n    //Disable watchdog for Arduino Due. watchdog\n#if (defined(_ROTH_DUE_))\n    watchdogDisable();\n#endif\n    \n    /*\n     * Initialize Serial Peripheral\n     */\n    // Always Initialize Serial0\n    Serial_begin(0, _RTT_BAUDRATE_SERIAL0_);\n    \n    /* Overrun Detection Initialization */\n#ifdef _RTT_OVERRUN_DIGITAL_PIN_\n    pinMode(_RTT_OVERRUN_DIGITAL_PIN_, OUTPUT);\n    \n    /* Init the overrun detection pin to zero or else the Pin is always in a\n     * high/tristate giving the user a wrong indication of overrun conditions */\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, LOW);\n#endif\n    \n    /*\n     * Initialize Analog Reference Voltage\n     * Default - Due\n     * Default, Internal 1.1, Internal 2.56, External -  Mega 2560, Mega ADK\n     * Default, Internal, External - Other Arduino targets\n     */\n#if (defined(_ROTH_MEGA2560_))\n#if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL1V1);\n#elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(INTERNAL2V56);\n#elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(EXTERNAL);\n#endif\n#elif defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_INTERNAL1V0);\n#elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL1V65);\n#elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL2V23);\n#elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_EXTERNAL);\n#endif\n#else\n#if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL);\n#elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(EXTERNAL);\n#endif\n#endif\n    \n    /*\n     * Initialize SPI bus\n     */\n    //_RTT_SPI_SSPIN_ definition is applicable for all boards excluding Due\n#if defined(_RTT_SPI_SSPIN_)\n    MW_SPIwriteReadSetup();\n#endif\n    \n    //Initialize Modbus\n    int modStatus;\n#if defined(_RTT_MODBUS_MASTER_)\n    modStatus = ModbusRTUClient.begin(_RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    ModbusRTUClient.setTimeout(_RTT_MODBUS_MASTERTIMEOUT_/1000);\n#endif\n    \n#if defined(_RTT_MODBUS_SLAVE_)\n    modStatus = ModbusRTUServer.begin(_RTT_MODBUS_SLAVEID_, _RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n#if defined(_RTT_MODBUS_CONFIGCOIL_)\n    ModbusRTUServer.configureCoils(_RTT_MODBUS_COILADDR_,_RTT_MODBUS_COILNUM_);\n#endif\n#if defined(_RTT_MODBUS_CONFIGINPUT_)\n    ModbusRTUServer.configureDiscreteInputs(_RTT_MODBUS_INPUPTADDR_,_RTT_MODBUS_INPUTNUM_);\n#endif\n#if defined(_RTT_MODBUS_CONFIGHOLDINGREG_)\n    ModbusRTUServer.configureHoldingRegisters(_RTT_MODBUS_HOLDINGREGADDR_,_RTT_MODBUS_HOLDINGREGNUM_);\n#endif\n#if defined(_RTT_MODBUS_CONFIGINPUTREG_)\n    ModbusRTUServer.configureInputRegisters(_RTT_MODBUS_INPUTREGADDR_,_RTT_MODBUS_INPUTREGNUM_);\n#endif\n#endif\n      \n/* \n * Initialize wifi      \n */\n#if (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_)\n    /* Begin WiFi*/\n    while(configureSuccess!=WL_CONNECTED)\n    {\n        #if (defined(_RTT_DISABLE_Wifi_DHCP_) && (_RTT_DISABLE_Wifi_DHCP_ !=0))\n            WiFi.config(wifiLocalIpAddress);\n        #endif\n\n        #ifdef _RTT_WIFI_WEP\n            configureSuccess=WiFi.begin(ssid,keyIndex,key);\n        #endif //_RTT_WIFI_WEP\n\n        #ifdef _RTT_WIFI_WPA\n            configureSuccess=WiFi.begin(ssid,wpapass);\n        #endif //_RTT_WIFI_WPA\n\n        #ifdef _RTT_WIFI_NONE\n            configureSuccess=WiFi.begin(ssid);\n        #endif //_RTT_WIFI_NONE\n\n            //Wait for 10 seconds for Wifi connection to happen\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 10000)\n            {\n            };\n    }\n\n    /* Wait for Serial0 to be up*/\n    for(trialcount=0;trialcount<5;trialcount++)\n    {\n        if(Serial)\n        {\n            break;\n        }else\n        {\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 1000)\n            {\n            };\n        }\n    }\n\n    #if (!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n        if (configureSuccess==WL_CONNECTED)\n        {\n            // If the Configuration is successful, relay back the assigned IP address.\n            IPAddress ip = WiFi.localIP();\n            Serial.print(\"<<< IP address :\");\n            Serial.print(ip);\n            Serial.println(\" >>>\");            \n        }\n        else\n        {\n           // If the Configuration failed,relay back the error message.\n           Serial.println(\"<<< IP address :Failed to configure. >>>\");\n        }\n    #endif //(!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))  \n\n#endif /*Initialize wifi*/\n  #ifdef NANO_MOTOR_CARRIER \n    MW_EnableNanoCarrierBatteryCharging();\n  #endif\n    #ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n    MW_initScreen();\n    #endif\n}\n/* Function: MW_Arduino_Terminate ================================================\n * For Arduino MKR/Leonardo and its variants, the Virtual COM port is handled\n * by the controller. In case the code running on the target exits main,\n * the COM port cannot be accessed until a hard reset is performed.\n * To over come this issue, a while loop is added to make sure that\n * upon getting a stop command from external mode, the code running on\n * the target stops but the code will not exit the main.\n * This will ensure that the COM port is accessible even after the\n * external mode has been stopped. */\nvoid MW_Arduino_Terminate(void){\n#if defined(ARDUINO_VIRTUAL_COM_PORT)\n    disable_rt_OneStep();\n    while(1){};     /* To continue virtual COM port functionality */\n#endif\n}\n\n#ifdef NANO_MOTOR_CARRIER\nvoid MW_EnableNanoCarrierBatteryCharging(void) {\n  Wire.begin();\n  Wire.beginTransmission(PMIC_ADDRESS);\n  Wire.write(PMIC_REG00);\n  Wire.write(0x06); // min sys voltage 3.88V + max input current 2.0 A\n  Wire.endTransmission();\n  Wire.beginTransmission(PMIC_ADDRESS);\n  Wire.write(PMIC_REG01);\n  Wire.write(0x1B); // Charge Battery + Minimum System Voltage 3.5V\n  Wire.endTransmission();\n  Wire.beginTransmission(PMIC_ADDRESS);\n  Wire.write(PMIC_REG02);\n  Wire.write(0x00); // Charge current  512 mA\n  Wire.endTransmission();\n  Wire.beginTransmission(PMIC_ADDRESS);\n  Wire.write(PMIC_REG04);\n  Wire.write(0x9E); // Charge Voltage Limit 4.128V\n  Wire.endTransmission();\n  Wire.beginTransmission(PMIC_ADDRESS);\n  Wire.write(PMIC_REG05);\n  Wire.write(0x8A); // Enable Battery Charge termination + disable watchdog\n  Wire.endTransmission();\n}\n#endif\n\n// LocalWords:  AVR Bareboard ADK SPI RTT SSPIN Modbus MKR\n"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"MW_ArduinoHWInit.h\"\n#include \"arduinoARMScheduler.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Arduino Due\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERNUM 3\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERSIZE 1000\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERNUM 3\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.arduinobase.registry.getBaudRate\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.arduinobase.internal.getExternalModeMexArgs('Serial')\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Ethernet')\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONWIFI_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Wifi')\n#define MW_CONNECTIONINFO_XCPONWIFI_PORT 17725\n#define MW_CONNECTIONINFO_XCPONWIFI_VERBOSE 0\n#define MW_CONNECTIONINFO_SERIAL_IPADDRESS codertarget.arduinobase.registry.getLoopbackIP;\n#define MW_CONNECTIONINFO_SERIAL_PORT 17725\n#define MW_CONNECTIONINFO_SERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_TCPIP_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Ethernet')\n#define MW_CONNECTIONINFO_TCPIP_PORT 17725\n#define MW_CONNECTIONINFO_TCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_WIFI_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Wifi')\n#define MW_CONNECTIONINFO_WIFI_PORT 17725\n#define MW_CONNECTIONINFO_WIFI_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_COMPORTBAUD 115200\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 0\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_FORCEBUILDSTATICLIBRARY 0\n#define MW_HOSTCOMPORT_SET_HOST_COM_PORT 0\n#define MW_HOSTCOMPORT_COM_PORT_NUMBER 1\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 13\n#define MW_ANALOGINREFVOLTAGE_ANALOG_INPUT_REFERENCE_VOLTAGE 0.000000\n#define MW_SERIAL_SERIAL0_BAUD_RATE 3\n#define MW_SERIAL_SERIAL1_BAUD_RATE 3\n#define MW_SERIAL_SERIAL2_BAUD_RATE 3\n#define MW_SERIAL_SERIAL3_BAUD_RATE 3\n#define MW_I2C_I2C0BUSSPEEDHZ 100000\n#define MW_I2C_I2C1BUSSPEEDHZ 100000\n#define MW_SPI_SPI_CLOCK_OUT_FREQUENCY 5\n#define MW_SPI_SPI_MODE 0\n#define MW_SPI_SPI_BITORDER 0\n#define MW_SPI_SDSLAVESELECT 4.000000\n#define MW_SPI_CANCHIPSELECT 10.000000\n#define MW_ETHERNET_DISABLE_DHCP_ETHERNET 0\n#define MW_ETHERNET_LOCAL_IP_ADDRESS 192.168.0.20\n#define MW_ETHERNET_LOCAL_MAC_ADDRESS DE:AD:BE:EF:FE:ED\n#define MW_WIFI_WIFI_HARDWARE 0\n#define MW_WIFI_DISABLE_DHCP_WIFI 0\n#define MW_WIFI_WIFI_IP_ADDRESS 192.168.1.20\n#define MW_WIFI_WIFI_SSID yourNetwork\n#define MW_WIFI_SET_WIFI_ENCRYPTION 0\n#define MW_WIFI_WIFI_WEP_KEY D0D0DEADF00DABBADEAFBEADED\n#define MW_WIFI_WIFI_WEP_KEY_INDEX 0\n#define MW_WIFI_WIFI_WPA_PASSWORD secretPassword\n#define MW_WIFI_WIFI_ESP8266_HW_SERIAL_PORT 0\n#define MW_THINGSPEAK_ENABLE_CUSTOMSERVER 48\n#define MW_THINGSPEAK_IP_ADDRESS 184.106.153.149\n#define MW_THINGSPEAK_PORT 80\n#define MW_CAN_CANBUSSPEED 10\n#define MW_CAN_CANOSCILLATORFREQUENCY 1\n#define MW_CAN_INTERRUPTPIN 2.000000\n#define MW_CAN_ALLOWALLFILTER 0\n#define MW_CAN_BUFFER0IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK0_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER0_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER1_NOR 255\n#define MW_CAN_ACCEPTANCEMASK0_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER0_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER1_EXT 255\n#define MW_CAN_BUFFER1IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK1_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER2_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER3_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER4_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER5_NOR 255\n#define MW_CAN_ACCEPTANCEMASK1_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER2_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER3_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER4_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER5_EXT 255\n#define MW_DISPLAY_ENABLECODEGEN 0\n#define MW_DISPLAY_APPLAUNCHBUTTON \n#define MW_DATAVERSION 2016.02\n#define MW_DASHBOARDCODEGENINFO_ENABLECODEGEN 0\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.circularGauge\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.lcdTextDisplay\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.pushButton\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_IOBLOCKSMODE deployed\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"SPI.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\aIDE\\portable\\packages\\arduino\\hardware\\sam\\1.6.12\\libraries\\SPI\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Copyright (c) 2010 by Cristian Maglie <c.maglie@arduino.cc>\n * Copyright (c) 2014 by Paul Stoffregen <paul@pjrc.com> (Transaction API)\n * SPI Master library for arduino.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of either the GNU General Public License version 2\n * or the GNU Lesser General Public License version 2.1, both as\n * published by the Free Software Foundation.\n */\n\n#include \"SPI.h\"\n\nSPIClass::SPIClass(Spi *_spi, uint32_t _id, void(*_initCb)(void)) :\n\tspi(_spi), id(_id), initCb(_initCb), initialized(false)\n{\n\t// Empty\n}\n\nvoid SPIClass::begin() {\n\tinit();\n\t// NPCS control is left to the user\n\n\t// Default speed set to 4Mhz\n\tsetClockDivider(BOARD_SPI_DEFAULT_SS, 21);\n\tsetDataMode(BOARD_SPI_DEFAULT_SS, SPI_MODE0);\n\tsetBitOrder(BOARD_SPI_DEFAULT_SS, MSBFIRST);\n}\n\nvoid SPIClass::begin(uint8_t _pin) {\n\tinit();\n\n\tuint32_t spiPin = BOARD_PIN_TO_SPI_PIN(_pin);\n\tPIO_Configure(\n\t\tg_APinDescription[spiPin].pPort,\n\t\tg_APinDescription[spiPin].ulPinType,\n\t\tg_APinDescription[spiPin].ulPin,\n\t\tg_APinDescription[spiPin].ulPinConfiguration);\n\n\t// Default speed set to 4Mhz\n\tsetClockDivider(_pin, 21);\n\tsetDataMode(_pin, SPI_MODE0);\n\tsetBitOrder(_pin, MSBFIRST);\n}\n\nvoid SPIClass::init() {\n\tif (initialized)\n\t\treturn;\n\tinterruptMode = 0;\n\tinterruptSave = 0;\n\tinterruptMask[0] = 0;\n\tinterruptMask[1] = 0;\n\tinterruptMask[2] = 0;\n\tinterruptMask[3] = 0;\n\tinitCb();\n\tSPI_Configure(spi, id, SPI_MR_MSTR | SPI_MR_PS | SPI_MR_MODFDIS);\n\tSPI_Enable(spi);\n\tinitialized = true;\n}\n\n#ifndef interruptsStatus\n#define interruptsStatus() __interruptsStatus()\nstatic inline unsigned char __interruptsStatus(void) __attribute__((always_inline, unused));\nstatic inline unsigned char __interruptsStatus(void) {\n\tunsigned int primask, faultmask;\n\tasm volatile (\"mrs %0, primask\" : \"=r\" (primask));\n\tif (primask) return 0;\n\tasm volatile (\"mrs %0, faultmask\" : \"=r\" (faultmask));\n\tif (faultmask) return 0;\n\treturn 1;\n}\n#endif\n\nvoid SPIClass::usingInterrupt(uint8_t interruptNumber)\n{\n\tuint8_t irestore;\n\n\tirestore = interruptsStatus();\n\tnoInterrupts();\n\tif (interruptMode < 16) {\n\t\tif (interruptNumber > NUM_DIGITAL_PINS) {\n\t\t\tinterruptMode = 16;\n\t\t} else {\n\t\t\tPio *pio = g_APinDescription[interruptNumber].pPort;\n\t\t\tuint32_t mask = g_APinDescription[interruptNumber].ulPin;\n\t\t\tif (pio == PIOA) {\n\t\t\t\tinterruptMode |= 1;\n\t\t\t\tinterruptMask[0] |= mask;\n\t\t\t} else if (pio == PIOB) {\n\t\t\t\tinterruptMode |= 2;\n\t\t\t\tinterruptMask[1] |= mask;\n\t\t\t} else if (pio == PIOC) {\n\t\t\t\tinterruptMode |= 4;\n\t\t\t\tinterruptMask[2] |= mask;\n\t\t\t} else if (pio == PIOD) {\n\t\t\t\tinterruptMode |= 8;\n\t\t\t\tinterruptMask[3] |= mask;\n\t\t\t} else {\n\t\t\t\tinterruptMode = 16;\n\t\t\t}\n\t\t}\n\t}\n\tif (irestore) interrupts();\n}\n\nvoid SPIClass::beginTransaction(uint8_t pin, SPISettings settings)\n{\n\tuint8_t mode = interruptMode;\n\tif (mode > 0) {\n\t\tif (mode < 16) {\n\t\t\tif (mode & 1) PIOA->PIO_IDR = interruptMask[0];\n\t\t\tif (mode & 2) PIOB->PIO_IDR = interruptMask[1];\n\t\t\tif (mode & 4) PIOC->PIO_IDR = interruptMask[2];\n\t\t\tif (mode & 8) PIOD->PIO_IDR = interruptMask[3];\n\t\t} else {\n\t\t\tinterruptSave = interruptsStatus();\n\t\t\tnoInterrupts();\n\t\t}\n\t}\n\tuint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(pin);\n\tbitOrder[ch] = settings.border;\n\tSPI_ConfigureNPCS(spi, ch, settings.config);\n\t//setBitOrder(pin, settings.border);\n\t//setDataMode(pin, settings.datamode);\n\t//setClockDivider(pin, settings.clockdiv);\n}\n\nvoid SPIClass::endTransaction(void)\n{\n\tuint8_t mode = interruptMode;\n\tif (mode > 0) {\n\t\tif (mode < 16) {\n\t\t\tif (mode & 1) PIOA->PIO_IER = interruptMask[0];\n\t\t\tif (mode & 2) PIOB->PIO_IER = interruptMask[1];\n\t\t\tif (mode & 4) PIOC->PIO_IER = interruptMask[2];\n\t\t\tif (mode & 8) PIOD->PIO_IER = interruptMask[3];\n\t\t} else {\n\t\t\tif (interruptSave) interrupts();\n\t\t}\n\t}\n}\n\nvoid SPIClass::end(uint8_t _pin) {\n\tuint32_t spiPin = BOARD_PIN_TO_SPI_PIN(_pin);\n\t// Setting the pin as INPUT will disconnect it from SPI peripheral\n\tpinMode(spiPin, INPUT);\n}\n\nvoid SPIClass::end() {\n\tSPI_Disable(spi);\n\tinitialized = false;\n}\n\nvoid SPIClass::setBitOrder(uint8_t _pin, BitOrder _bitOrder) {\n\tuint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);\n\tbitOrder[ch] = _bitOrder;\n}\n\nvoid SPIClass::setDataMode(uint8_t _pin, uint8_t _mode) {\n\tuint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);\n\tmode[ch] = _mode | SPI_CSR_CSAAT;\n\t// SPI_CSR_DLYBCT(1) keeps CS enabled for 32 MCLK after a completed\n\t// transfer. Some device needs that for working properly.\n\tSPI_ConfigureNPCS(spi, ch, mode[ch] | SPI_CSR_SCBR(divider[ch]) | SPI_CSR_DLYBCT(1));\n}\n\nvoid SPIClass::setClockDivider(uint8_t _pin, uint8_t _divider) {\n\tuint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);\n\tdivider[ch] = _divider;\n\t// SPI_CSR_DLYBCT(1) keeps CS enabled for 32 MCLK after a completed\n\t// transfer. Some device needs that for working properly.\n\tSPI_ConfigureNPCS(spi, ch, mode[ch] | SPI_CSR_SCBR(divider[ch]) | SPI_CSR_DLYBCT(1));\n}\n\nbyte SPIClass::transfer(byte _pin, uint8_t _data, SPITransferMode _mode) {\n\tuint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);\n\t// Reverse bit order\n\tif (bitOrder[ch] == LSBFIRST)\n\t\t_data = __REV(__RBIT(_data));\n\tuint32_t d = _data | SPI_PCS(ch);\n\tif (_mode == SPI_LAST)\n\t\td |= SPI_TDR_LASTXFER;\n\n\t// SPI_Write(spi, _channel, _data);\n\twhile ((spi->SPI_SR & SPI_SR_TDRE) == 0)\n\t\t;\n\tspi->SPI_TDR = d;\n\n\t// return SPI_Read(spi);\n\twhile ((spi->SPI_SR & SPI_SR_RDRF) == 0)\n\t\t;\n\td = spi->SPI_RDR;\n\t// Reverse bit order\n\tif (bitOrder[ch] == LSBFIRST)\n\t\td = __REV(__RBIT(d));\n\treturn d & 0xFF;\n}\n\nuint16_t SPIClass::transfer16(byte _pin, uint16_t _data, SPITransferMode _mode) {\n\tunion { uint16_t val; struct { uint8_t lsb; uint8_t msb; }; } t;\n\tuint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);\n\n\tt.val = _data;\n\n\tif (bitOrder[ch] == LSBFIRST) {\n\t\tt.lsb = transfer(_pin, t.lsb, SPI_CONTINUE);\n\t\tt.msb = transfer(_pin, t.msb, _mode);\n\t} else {\n\t\tt.msb = transfer(_pin, t.msb, SPI_CONTINUE);\n\t\tt.lsb = transfer(_pin, t.lsb, _mode);\n\t}\n\n\treturn t.val;\n}\n\nvoid SPIClass::transfer(byte _pin, void *_buf, size_t _count, SPITransferMode _mode) {\n\tif (_count == 0)\n\t\treturn;\n\n\tuint8_t *buffer = (uint8_t *)_buf;\n\tif (_count == 1) {\n\t\t*buffer = transfer(_pin, *buffer, _mode);\n\t\treturn;\n\t}\n\n\tuint32_t ch = BOARD_PIN_TO_SPI_CHANNEL(_pin);\n\tbool reverse = (bitOrder[ch] == LSBFIRST);\n\n\t// Send the first byte\n\tuint32_t d = *buffer;\n\tif (reverse)\n\t\td = __REV(__RBIT(d));\n\twhile ((spi->SPI_SR & SPI_SR_TDRE) == 0)\n\t\t;\n\tspi->SPI_TDR = d | SPI_PCS(ch);\n\n\twhile (_count > 1) {\n\t\t// Prepare next byte\n\t\td = *(buffer+1);\n\t\tif (reverse)\n\t\t\td = __REV(__RBIT(d));\n\t\tif (_count == 2 && _mode == SPI_LAST)\n\t\t\td |= SPI_TDR_LASTXFER;\n\n\t\t// Read transferred byte and send next one straight away\n\t\twhile ((spi->SPI_SR & SPI_SR_RDRF) == 0)\n\t\t\t;\n\t\tuint8_t r = spi->SPI_RDR;\n\t\tspi->SPI_TDR = d | SPI_PCS(ch);\n\n\t\t// Save read byte\n\t\tif (reverse)\n\t\t\tr = __REV(__RBIT(r));\n\t\t*buffer = r;\n\t\tbuffer++;\n\t\t_count--;\n\t}\n\n\t// Receive the last transferred byte\n\twhile ((spi->SPI_SR & SPI_SR_RDRF) == 0)\n\t\t;\n\tuint8_t r = spi->SPI_RDR;\n\tif (reverse)\n\t\tr = __REV(__RBIT(r));\n\t*buffer = r;\n}\n\nvoid SPIClass::attachInterrupt(void) {\n\t// Should be enableInterrupt()\n}\n\nvoid SPIClass::detachInterrupt(void) {\n\t// Should be disableInterrupt()\n}\n\n#if SPI_INTERFACES_COUNT > 0\nstatic void SPI_0_Init(void) {\n\tPIO_Configure(\n\t\t\tg_APinDescription[PIN_SPI_MOSI].pPort,\n\t\t\tg_APinDescription[PIN_SPI_MOSI].ulPinType,\n\t\t\tg_APinDescription[PIN_SPI_MOSI].ulPin,\n\t\t\tg_APinDescription[PIN_SPI_MOSI].ulPinConfiguration);\n\tPIO_Configure(\n\t\t\tg_APinDescription[PIN_SPI_MISO].pPort,\n\t\t\tg_APinDescription[PIN_SPI_MISO].ulPinType,\n\t\t\tg_APinDescription[PIN_SPI_MISO].ulPin,\n\t\t\tg_APinDescription[PIN_SPI_MISO].ulPinConfiguration);\n\tPIO_Configure(\n\t\t\tg_APinDescription[PIN_SPI_SCK].pPort,\n\t\t\tg_APinDescription[PIN_SPI_SCK].ulPinType,\n\t\t\tg_APinDescription[PIN_SPI_SCK].ulPin,\n\t\t\tg_APinDescription[PIN_SPI_SCK].ulPinConfiguration);\n}\n\nSPIClass SPI(SPI_INTERFACE, SPI_INTERFACE_ID, SPI_0_Init);\n#endif\n\n"},{"name":"Wire.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\aIDE\\portable\\packages\\arduino\\hardware\\sam\\1.6.12\\libraries\\Wire\\src","tag":"","groupDisplay":"Other files","code":"/*\n * TwoWire.h - TWI/I2C library for Arduino Due\n * Copyright (c) 2011 Cristian Maglie <c.maglie@arduino.cc>\n * All rights reserved.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\nextern \"C\" {\n#include <string.h>\n}\n\n#include \"Wire.h\"\n\nstatic inline bool TWI_FailedAcknowledge(Twi *pTwi) {\n\treturn pTwi->TWI_SR & TWI_SR_NACK;\n}\n\nstatic inline bool TWI_WaitTransferComplete(Twi *_twi, uint32_t _timeout) {\n\tuint32_t _status_reg = 0;\n\twhile ((_status_reg & TWI_SR_TXCOMP) != TWI_SR_TXCOMP) {\n\t\t_status_reg = TWI_GetStatus(_twi);\n\n\t\tif (_status_reg & TWI_SR_NACK)\n\t\t\treturn false;\n\n\t\tif (--_timeout == 0)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic inline bool TWI_WaitByteSent(Twi *_twi, uint32_t _timeout) {\n\tuint32_t _status_reg = 0;\n\twhile ((_status_reg & TWI_SR_TXRDY) != TWI_SR_TXRDY) {\n\t\t_status_reg = TWI_GetStatus(_twi);\n\n\t\tif (_status_reg & TWI_SR_NACK)\n\t\t\treturn false;\n\n\t\tif (--_timeout == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool TWI_WaitByteReceived(Twi *_twi, uint32_t _timeout) {\n\tuint32_t _status_reg = 0;\n\twhile ((_status_reg & TWI_SR_RXRDY) != TWI_SR_RXRDY) {\n\t\t_status_reg = TWI_GetStatus(_twi);\n\n\t\tif (_status_reg & TWI_SR_NACK)\n\t\t\treturn false;\n\n\t\tif (--_timeout == 0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic inline bool TWI_STATUS_SVREAD(uint32_t status) {\n\treturn (status & TWI_SR_SVREAD) == TWI_SR_SVREAD;\n}\n\nstatic inline bool TWI_STATUS_SVACC(uint32_t status) {\n\treturn (status & TWI_SR_SVACC) == TWI_SR_SVACC;\n}\n\nstatic inline bool TWI_STATUS_GACC(uint32_t status) {\n\treturn (status & TWI_SR_GACC) == TWI_SR_GACC;\n}\n\nstatic inline bool TWI_STATUS_EOSACC(uint32_t status) {\n\treturn (status & TWI_SR_EOSACC) == TWI_SR_EOSACC;\n}\n\nstatic inline bool TWI_STATUS_NACK(uint32_t status) {\n\treturn (status & TWI_SR_NACK) == TWI_SR_NACK;\n}\n\nTwoWire::TwoWire(Twi *_twi, void(*_beginCb)(void), void(*_endCb)(void)) :\n\ttwi(_twi), rxBufferIndex(0), rxBufferLength(0), txAddress(0),\n\t\t\ttxBufferLength(0), srvBufferIndex(0), srvBufferLength(0), status(\n\t\t\t\t\tUNINITIALIZED), onBeginCallback(_beginCb), \n\t\t\t\t\t\tonEndCallback(_endCb), twiClock(TWI_CLOCK) {\n}\n\nvoid TwoWire::begin(void) {\n\tif (onBeginCallback)\n\t\tonBeginCallback();\n\n\t// Disable PDC channel\n\ttwi->TWI_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;\n\n\tTWI_ConfigureMaster(twi, twiClock, VARIANT_MCK);\n\tstatus = MASTER_IDLE;\n}\n\nvoid TwoWire::begin(uint8_t address) {\n\tif (onBeginCallback)\n\t\tonBeginCallback();\n\n\t// Disable PDC channel\n\ttwi->TWI_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;\n\n\tTWI_ConfigureSlave(twi, address);\n\tstatus = SLAVE_IDLE;\n\tTWI_EnableIt(twi, TWI_IER_SVACC);\n\t//| TWI_IER_RXRDY | TWI_IER_TXRDY\t| TWI_IER_TXCOMP);\n}\n\nvoid TwoWire::begin(int address) {\n\tbegin((uint8_t) address);\n}\n\nvoid TwoWire::end(void) {\n\tTWI_Disable(twi);\n\n\t// Enable PDC channel\n\ttwi->TWI_PTCR &= ~(UART_PTCR_RXTDIS | UART_PTCR_TXTDIS);\n\n\tif (onEndCallback)\n\t\tonEndCallback();\n}\n\nvoid TwoWire::setClock(uint32_t frequency) {\n\ttwiClock = frequency;\n\tTWI_SetClock(twi, twiClock, VARIANT_MCK);\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint32_t iaddress, uint8_t isize, uint8_t sendStop) {\n\tif (quantity > BUFFER_LENGTH)\n\t\tquantity = BUFFER_LENGTH;\n\n\t// perform blocking read into buffer\n\tint readed = 0;\n\tTWI_StartRead(twi, address, iaddress, isize);\n\tdo {\n\t\t// Stop condition must be set during the reception of last byte\n\t\tif (readed + 1 == quantity)\n\t\t\tTWI_SendSTOPCondition( twi);\n\n\t\tif (TWI_WaitByteReceived(twi, RECV_TIMEOUT))\n\t\t\trxBuffer[readed++] = TWI_ReadByte(twi);\n\t\telse\n\t\t\tbreak;\n\t} while (readed < quantity);\n\tTWI_WaitTransferComplete(twi, RECV_TIMEOUT);\n\n\t// set rx buffer iterator vars\n\trxBufferIndex = 0;\n\trxBufferLength = readed;\n\n\treturn readed;\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop) {\n\treturn requestFrom((uint8_t) address, (uint8_t) quantity, (uint32_t) 0, (uint8_t) 0, (uint8_t) sendStop);\n}\n\nuint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity) {\n\treturn requestFrom((uint8_t) address, (uint8_t) quantity, (uint8_t) true);\n}\n\nuint8_t TwoWire::requestFrom(int address, int quantity) {\n\treturn requestFrom((uint8_t) address, (uint8_t) quantity, (uint8_t) true);\n}\n\nuint8_t TwoWire::requestFrom(int address, int quantity, int sendStop) {\n\treturn requestFrom((uint8_t) address, (uint8_t) quantity, (uint8_t) sendStop);\n}\n\nvoid TwoWire::beginTransmission(uint8_t address) {\n\tstatus = MASTER_SEND;\n\n\t// save address of target and empty buffer\n\ttxAddress = address;\n\ttxBufferLength = 0;\n}\n\nvoid TwoWire::beginTransmission(int address) {\n\tbeginTransmission((uint8_t) address);\n}\n\n//\n//\tOriginally, 'endTransmission' was an f(void) function.\n//\tIt has been modified to take one parameter indicating\n//\twhether or not a STOP should be performed on the bus.\n//\tCalling endTransmission(false) allows a sketch to\n//\tperform a repeated start.\n//\n//\tWARNING: Nothing in the library keeps track of whether\n//\tthe bus tenure has been properly ended with a STOP. It\n//\tis very possible to leave the bus in a hung state if\n//\tno call to endTransmission(true) is made. Some I2C\n//\tdevices will behave oddly if they do not see a STOP.\n//\nuint8_t TwoWire::endTransmission(uint8_t sendStop) {\n\tuint8_t error = 0;\n\t// transmit buffer (blocking)\n\tTWI_StartWrite(twi, txAddress, 0, 0, txBuffer[0]);\n\tif (!TWI_WaitByteSent(twi, XMIT_TIMEOUT))\n\t\terror = 2;\t// error, got NACK on address transmit\n\t\n\tif (error == 0) {\n\t\tuint16_t sent = 1;\n\t\twhile (sent < txBufferLength) {\n\t\t\tTWI_WriteByte(twi, txBuffer[sent++]);\n\t\t\tif (!TWI_WaitByteSent(twi, XMIT_TIMEOUT))\n\t\t\t\terror = 3;\t// error, got NACK during data transmmit\n\t\t}\n\t}\n\t\n\tif (error == 0) {\n\t\tTWI_Stop(twi);\n\t\tif (!TWI_WaitTransferComplete(twi, XMIT_TIMEOUT))\n\t\t\terror = 4;\t// error, finishing up\n\t}\n\n\ttxBufferLength = 0;\t\t// empty buffer\n\tstatus = MASTER_IDLE;\n\treturn error;\n}\n\n//\tThis provides backwards compatibility with the original\n//\tdefinition, and expected behaviour, of endTransmission\n//\nuint8_t TwoWire::endTransmission(void)\n{\n\treturn endTransmission(true);\n}\n\nsize_t TwoWire::write(uint8_t data) {\n\tif (status == MASTER_SEND) {\n\t\tif (txBufferLength >= BUFFER_LENGTH)\n\t\t\treturn 0;\n\t\ttxBuffer[txBufferLength++] = data;\n\t\treturn 1;\n\t} else {\n\t\tif (srvBufferLength >= BUFFER_LENGTH)\n\t\t\treturn 0;\n\t\tsrvBuffer[srvBufferLength++] = data;\n\t\treturn 1;\n\t}\n}\n\nsize_t TwoWire::write(const uint8_t *data, size_t quantity) {\n\tif (status == MASTER_SEND) {\n\t\tfor (size_t i = 0; i < quantity; ++i) {\n\t\t\tif (txBufferLength >= BUFFER_LENGTH)\n\t\t\t\treturn i;\n\t\t\ttxBuffer[txBufferLength++] = data[i];\n\t\t}\n\t} else {\n\t\tfor (size_t i = 0; i < quantity; ++i) {\n\t\t\tif (srvBufferLength >= BUFFER_LENGTH)\n\t\t\t\treturn i;\n\t\t\tsrvBuffer[srvBufferLength++] = data[i];\n\t\t}\n\t}\n\treturn quantity;\n}\n\nint TwoWire::available(void) {\n\treturn rxBufferLength - rxBufferIndex;\n}\n\nint TwoWire::read(void) {\n\tif (rxBufferIndex < rxBufferLength)\n\t\treturn rxBuffer[rxBufferIndex++];\n\treturn -1;\n}\n\nint TwoWire::peek(void) {\n\tif (rxBufferIndex < rxBufferLength)\n\t\treturn rxBuffer[rxBufferIndex];\n\treturn -1;\n}\n\nvoid TwoWire::flush(void) {\n\t// Do nothing, use endTransmission(..) to force\n\t// data transfer.\n}\n\nvoid TwoWire::onReceive(void(*function)(int)) {\n\tonReceiveCallback = function;\n}\n\nvoid TwoWire::onRequest(void(*function)(void)) {\n\tonRequestCallback = function;\n}\n\nvoid TwoWire::onService(void) {\n\t// Retrieve interrupt status\n\tuint32_t sr = TWI_GetStatus(twi);\n\n\tif (status == SLAVE_IDLE && TWI_STATUS_SVACC(sr)) {\n\t\tTWI_DisableIt(twi, TWI_IDR_SVACC);\n\t\tTWI_EnableIt(twi, TWI_IER_RXRDY | TWI_IER_GACC | TWI_IER_NACK\n\t\t\t\t| TWI_IER_EOSACC | TWI_IER_SCL_WS | TWI_IER_TXCOMP);\n\n\t\tsrvBufferLength = 0;\n\t\tsrvBufferIndex = 0;\n\n\t\t// Detect if we should go into RECV or SEND status\n\t\t// SVREAD==1 means *master* reading -> SLAVE_SEND\n\t\tif (!TWI_STATUS_SVREAD(sr)) {\n\t\t\tstatus = SLAVE_RECV;\n\t\t} else {\n\t\t\tstatus = SLAVE_SEND;\n\n\t\t\t// Alert calling program to generate a response ASAP\n\t\t\tif (onRequestCallback)\n\t\t\t\tonRequestCallback();\n\t\t\telse\n\t\t\t\t// create a default 1-byte response\n\t\t\t\twrite((uint8_t) 0);\n\t\t}\n\t}\n\n\tif (status != SLAVE_IDLE && TWI_STATUS_EOSACC(sr)) {\n\t\tif (status == SLAVE_RECV && onReceiveCallback) {\n\t\t\t// Copy data into rxBuffer\n\t\t\t// (allows to receive another packet while the\n\t\t\t// user program reads actual data)\n\t\t\tfor (uint8_t i = 0; i < srvBufferLength; ++i)\n\t\t\t\trxBuffer[i] = srvBuffer[i];\n\t\t\trxBufferIndex = 0;\n\t\t\trxBufferLength = srvBufferLength;\n\n\t\t\t// Alert calling program\n\t\t\tonReceiveCallback( rxBufferLength);\n\t\t}\n\n\t\t// Transfer completed\n\t\tTWI_EnableIt(twi, TWI_SR_SVACC);\n\t\tTWI_DisableIt(twi, TWI_IDR_RXRDY | TWI_IDR_GACC | TWI_IDR_NACK\n\t\t\t\t| TWI_IDR_EOSACC | TWI_IDR_SCL_WS | TWI_IER_TXCOMP);\n\t\tstatus = SLAVE_IDLE;\n\t}\n\n\tif (status == SLAVE_RECV) {\n\t\tif (TWI_STATUS_RXRDY(sr)) {\n\t\t\tif (srvBufferLength < BUFFER_LENGTH)\n\t\t\t\tsrvBuffer[srvBufferLength++] = TWI_ReadByte(twi);\n\t\t}\n\t}\n\n\tif (status == SLAVE_SEND) {\n\t\tif (TWI_STATUS_TXRDY(sr) && !TWI_STATUS_NACK(sr)) {\n\t\t\tuint8_t c = 'x';\n\t\t\tif (srvBufferIndex < srvBufferLength)\n\t\t\t\tc = srvBuffer[srvBufferIndex++];\n\t\t\tTWI_WriteByte(twi, c);\n\t\t}\n\t}\n}\n\n#if WIRE_INTERFACES_COUNT > 0\nstatic void Wire_Init(void) {\n\tpmc_enable_periph_clk(WIRE_INTERFACE_ID);\n\tPIO_Configure(\n\t\t\tg_APinDescription[PIN_WIRE_SDA].pPort,\n\t\t\tg_APinDescription[PIN_WIRE_SDA].ulPinType,\n\t\t\tg_APinDescription[PIN_WIRE_SDA].ulPin,\n\t\t\tg_APinDescription[PIN_WIRE_SDA].ulPinConfiguration);\n\tPIO_Configure(\n\t\t\tg_APinDescription[PIN_WIRE_SCL].pPort,\n\t\t\tg_APinDescription[PIN_WIRE_SCL].ulPinType,\n\t\t\tg_APinDescription[PIN_WIRE_SCL].ulPin,\n\t\t\tg_APinDescription[PIN_WIRE_SCL].ulPinConfiguration);\n\n\tNVIC_DisableIRQ(WIRE_ISR_ID);\n\tNVIC_ClearPendingIRQ(WIRE_ISR_ID);\n\tNVIC_SetPriority(WIRE_ISR_ID, 0);\n\tNVIC_EnableIRQ(WIRE_ISR_ID);\n}\n\nstatic void Wire_Deinit(void) {\n\tNVIC_DisableIRQ(WIRE_ISR_ID);\n\tNVIC_ClearPendingIRQ(WIRE_ISR_ID);\n\n\tpmc_disable_periph_clk(WIRE_INTERFACE_ID);\n\n\t// no need to undo PIO_Configure, \n\t// as Peripheral A was enable by default before,\n\t// and pullups were not enabled\n}\n\nTwoWire Wire = TwoWire(WIRE_INTERFACE, Wire_Init, Wire_Deinit);\n\nvoid WIRE_ISR_HANDLER(void) {\n\tWire.onService();\n}\n#endif\n\n#if WIRE_INTERFACES_COUNT > 1\nstatic void Wire1_Init(void) {\n\tpmc_enable_periph_clk(WIRE1_INTERFACE_ID);\n\tPIO_Configure(\n\t\t\tg_APinDescription[PIN_WIRE1_SDA].pPort,\n\t\t\tg_APinDescription[PIN_WIRE1_SDA].ulPinType,\n\t\t\tg_APinDescription[PIN_WIRE1_SDA].ulPin,\n\t\t\tg_APinDescription[PIN_WIRE1_SDA].ulPinConfiguration);\n\tPIO_Configure(\n\t\t\tg_APinDescription[PIN_WIRE1_SCL].pPort,\n\t\t\tg_APinDescription[PIN_WIRE1_SCL].ulPinType,\n\t\t\tg_APinDescription[PIN_WIRE1_SCL].ulPin,\n\t\t\tg_APinDescription[PIN_WIRE1_SCL].ulPinConfiguration);\n\n\tNVIC_DisableIRQ(WIRE1_ISR_ID);\n\tNVIC_ClearPendingIRQ(WIRE1_ISR_ID);\n\tNVIC_SetPriority(WIRE1_ISR_ID, 0);\n\tNVIC_EnableIRQ(WIRE1_ISR_ID);\n}\n\nstatic void Wire1_Deinit(void) {\n\tNVIC_DisableIRQ(WIRE1_ISR_ID);\n\tNVIC_ClearPendingIRQ(WIRE1_ISR_ID);\n\n\tpmc_disable_periph_clk(WIRE1_INTERFACE_ID);\n\n\t// no need to undo PIO_Configure, \n\t// as Peripheral A was enable by default before,\n\t// and pullups were not enabled\n}\n\nTwoWire Wire1 = TwoWire(WIRE1_INTERFACE, Wire1_Init, Wire1_Deinit);\n\nvoid WIRE1_ISR_HANDLER(void) {\n\tWire1.onService();\n}\n#endif\n"},{"name":"arduinoARMScheduler.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\arduinotarget\\registry\\..\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino ARM M3 Bareboard scheduler\n *\n * Copyright 2013-2020 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"arduinoARMScheduler.h\"\n#include \"Reset.h\"\n/* Multi tasking related header file */\n#include \"arm_cortex_m_multitasking.h\"\n\nextern volatile int IsrOverrun;\nunsigned long oldtime = 0L;\nunsigned long actualtime;\n\nextern volatile uint32_t taskToSchedule;\n\n/*\n * Call the rt_Onestep function when the timer interrupt hits     \n *\n */\nstatic void Scheduler_Isr(void)\n{\n    DISABLE_SCHEDULER_INT();\n\n    /* DSB (Data Synchronization Barrier) operation will complete when all \n     * explicit memory accesses before this instruction have completed.\n     * No instructions after the DSB will be executed until the DSB\n     * instruction has completed, that is, when all of the pending accesses\n     * have completed. */\n    __DSB();\n\n    /* ISB (Instruction Synchronization Barrier)flushes the pipeline in\n     * the processor, so that all instructions following the ISB are\n     * fetched from cache or memory, after the instruction has been\n     * completed. It ensures that changes to the system, for example\n     * the MPU, take immediate effect.*/\n    __ISB();\n    \n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n          // Overrun detected\n          digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n    #endif\n    \n\trt_OneStep();\n\n    ENABLE_SCHEDULER_INT();\n}\n\n#ifndef _MW_ARDUINO_LOOP_\n#if defined(_ARDUINO_DUE_TIMER_6_)\nvoid TC6_Handler() {\n#elif defined(_ARDUINO_DUE_TIMER_7_)\nvoid TC7_Handler() {\n#elif defined(_ARDUINO_DUE_TIMER_8_)\nvoid TC8_Handler() {\n#endif\n    /* Needs to be called to re-enable the Timer interrupt */\n\t#if defined(_ARDUINO_DUE_TIMER_6_)\n\tTC_GetStatus(TC2, 0);\n\t#elif defined(_ARDUINO_DUE_TIMER_7_)\n\tTC_GetStatus(TC2, 1);\n\t#elif defined(_ARDUINO_DUE_TIMER_8_)\n\tTC_GetStatus(TC2, 2);\n\t#endif\n\tSCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;\n}\n#endif\n\nvoid configureArduinoARMTimer(void)\n{\n    #if defined(_ARDUINO_DUE_TIMER_6_)\n      Setup_SchedulerTimer(TC_FOR_TIMER6, CHANNEL_FOR_TIMER6, ID_TC_FOR_TIMER6, IRQn_FOR_TIMER6, MW_SAM_CLOCKID, MW_TIMERCOUNT);\n    #elif defined(_ARDUINO_DUE_TIMER_7_) \n      Setup_SchedulerTimer(TC_FOR_TIMER7, CHANNEL_FOR_TIMER7, ID_TC_FOR_TIMER7, IRQn_FOR_TIMER7, MW_SAM_CLOCKID, MW_TIMERCOUNT);\n    #elif defined(_ARDUINO_DUE_TIMER_8_) \n      Setup_SchedulerTimer(TC_FOR_TIMER8, CHANNEL_FOR_TIMER8, ID_TC_FOR_TIMER8, IRQn_FOR_TIMER8, MW_SAM_CLOCKID, MW_TIMERCOUNT);\n    #endif\n    /* Set PendSV and SVC to least priority */\n    NVIC_SetPriority((IRQn_Type)(-5), MW_MAX_PRIORITY_VALUE);\n    NVIC_SetPriority((IRQn_Type)(-2), MW_MAX_PRIORITY_VALUE);\n    taskToSchedule = (uint32_t) Scheduler_Isr;\n}\n\nvoid Setup_SchedulerTimer(Tc *tc, uint32_t channel, uint32_t id, IRQn_Type irqn, uint8_t clockid, uint32_t tickcounter)\n{\n#ifndef _MW_ARDUINO_LOOP_\n    pmc_set_writeprotect(false);\n    pmc_enable_periph_clk(id);\n    \n    TC_Configure(tc, channel, TC_CMR_WAVE | TC_CMR_WAVSEL_UP_RC | clockid);\n    \n    TC_SetRC(tc, channel, tickcounter);\n    \n    TC_Start(tc, channel);\n    \n    tc->TC_CHANNEL[channel].TC_IER=TC_IER_CPCS;\n    tc->TC_CHANNEL[channel].TC_IDR=~TC_IER_CPCS;\n    \n    NVIC_SetPriority(irqn, 0x00);\n    NVIC_EnableIRQ(irqn);\n#endif    \n}\n\nboolean disable_rt_OneStep(void)\n{\n    boolean t_return = 0U;\n#ifndef _MW_ARDUINO_LOOP_\n  // Disable the overflow interrupt for XCP External Mode\n    #if defined(_ARDUINO_DUE_TIMER_6_)\n        if (NVIC->ISER[((uint32_t)(IRQn_FOR_TIMER6) >> 5)] = (1 << ((uint32_t)(IRQn_FOR_TIMER6) & 0x1F)))\n        {\n            t_return = 1U;\n        }\n        NVIC_DisableIRQ(IRQn_FOR_TIMER6);\n    #elif defined(_ARDUINO_DUE_TIMER_7_)\n        if (NVIC->ISER[((uint32_t)(IRQn_FOR_TIMER7) >> 5)] = (1 << ((uint32_t)(IRQn_FOR_TIMER7) & 0x1F)))\n        {\n            t_return = 1U;\n        }\n        NVIC_DisableIRQ(IRQn_FOR_TIMER7);\n    #elif defined(_ARDUINO_DUE_TIMER_8_)\n        if (NVIC->ISER[((uint32_t)(IRQn_FOR_TIMER8) >> 5)] = (1 << ((uint32_t)(IRQn_FOR_TIMER8) & 0x1F)))\n        {\n            t_return = 1U;\n        }\n        NVIC_DisableIRQ(IRQn_FOR_TIMER8);\n    #endif\n#endif \n    return t_return;\n}\n\nvoid enable_rt_OneStep(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n  // Enable the overflow interrupt\n    #if defined(_ARDUINO_DUE_TIMER_6_)\n        NVIC_EnableIRQ(IRQn_FOR_TIMER6);\n    #elif defined(_ARDUINO_DUE_TIMER_7_)\n        NVIC_EnableIRQ(IRQn_FOR_TIMER7);\n    #elif defined(_ARDUINO_DUE_TIMER_8_)\n        NVIC_EnableIRQ(IRQn_FOR_TIMER8);\n    #endif\n#endif            \n}\n\nboolean MW_Arduino_Loop(void)\n{\n    boolean ret = 0;\n\n#ifdef _MW_ARDUINO_LOOP_\n    unsigned long overruntime;\n\n#if (defined(MW_ARDUINO_MICROS))\n    actualtime = micros();\n#else\n    actualtime = millis();\n#endif\n\n    if ((unsigned long) (actualtime - oldtime) >= MW_ARDUINO_STEP_SIZE)\n    {\n        oldtime = actualtime;\n        \n#ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n            // Overrun detected\n            digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n#endif\n        rt_OneStep();\n\n             #if (defined(_MW_ARDUINO_LOOP_))\n                #if (defined(MW_ARDUINO_MICROS))\n                        overruntime = micros();\n                #else\n                        overruntime = millis();\n                #endif\n                if ((unsigned long) (overruntime - oldtime) >= MW_ARDUINO_STEP_SIZE)   \n                  IsrOverrun = 1;\n                else\n                  IsrOverrun = 0;\n            #endif\n    }\n#endif\n        \n    ret = 1;\n    return ret;\n}\n\n// LocalWords:  Bareboard Onestep DSB ISB MPU SVC XCP\n"},{"name":"arm_m3_cortex_handler.c","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\arduinotarget\\registry\\..\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Arduino ARM M3 Cortex handler\n *\n * Copyright 2019-2020 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"Reset.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstatic void __halt() {\n\t// Halts\n\twhile (1)\n\t\t;\n}\n\nextern void svcHook(void);\nextern void pendSVHook(void);\nextern int sysTickHook(void);\n\n/* Cortex-M3 core handlers */\nvoid NMI_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid HardFault_Handler (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid MemManage_Handler (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid BusFault_Handler  (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid UsageFault_Handler(void) __attribute__ ((weak, alias(\"__halt\")));\nvoid DebugMon_Handler  (void) __attribute__ ((weak, alias(\"__halt\")));\n\n// Setting SVC_Handler/PendSV as \"weak\" as later it can be defined Naked\n// Naked attribute is required because SVC_Handler/PendSV calls svcHook/pendSVHook which is a naked function.\n// Naked functions do not need prologue/epilogue generated by the compiler\n__attribute__ ((weak)) void SVC_Handler (void) { svcHook(); }\n__attribute__ ((weak)) void PendSV_Handler    (void) {\tpendSVHook(); }\n\nvoid SysTick_Handler(void)\n{\n\tif (sysTickHook())\n\t\treturn;\n\n\ttickReset();\n\n\t// Increment tick count each ms\n\tTimeTick_Increment();\n}\n\n/* Peripherals handlers */\nvoid SUPC_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid RSTC_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid RTC_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid RTT_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid WDT_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid PMC_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid EFC0_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid EFC1_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid UART_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#ifdef _SAM3XA_SMC_INSTANCE_\nvoid SMC_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\n#ifdef _SAM3XA_SDRAMC_INSTANCE_\nvoid SDRAMC_Handler     (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\nvoid PIOA_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid PIOB_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#ifdef _SAM3XA_PIOC_INSTANCE_\nvoid PIOC_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\n#ifdef _SAM3XA_PIOD_INSTANCE_\nvoid PIOD_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\n#ifdef _SAM3XA_PIOE_INSTANCE_\nvoid PIOE_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\n#ifdef _SAM3XA_PIOF_INSTANCE_\nvoid PIOF_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\nvoid USART0_Handler     (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid USART1_Handler     (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid USART2_Handler     (void) __attribute__ ((weak, alias(\"__halt\")));\n#ifdef _SAM3XA_USART3_INSTANCE_\nvoid USART3_Handler     (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\nvoid HSMCI_Handler      (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TWI0_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TWI1_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid SPI0_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#ifdef _SAM3XA_SPI1_INSTANCE_\nvoid SPI1_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\nvoid SSC_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC0_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC1_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC2_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC3_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC4_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC5_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\n#ifdef _SAM3XA_TC2_INSTANCE_\nvoid TC6_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC7_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TC8_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\nvoid PWM_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid ADC_Handler        (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid DACC_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid DMAC_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid UOTGHS_Handler     (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid TRNG_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#ifdef _SAM3XA_EMAC_INSTANCE_\nvoid EMAC_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n#endif\nvoid CAN0_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\nvoid CAN1_Handler       (void) __attribute__ ((weak, alias(\"__halt\")));\n\n#ifdef __cplusplus\n}\n#endif\n/*\n * LocalWords:  SVC svc\n */\n"},{"name":"io_wrappers.cpp","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\arduinobase\\src","tag":"","groupDisplay":"Other files","code":"/*\n * Wrappers to make I/O functions available with C linkage. This allows C++\n * methods to be called from C code.\n *\n * Copyright 2011-2020 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"rtwtypes.h\"\n\n#if (defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)) || (defined(_RTT_UDP_) && (_RTT_UDP_ != 0)) || (defined(_RTT_TCP_) && (_RTT_TCP_ != 0) || defined(_RTT_THINGSPEAK_))\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n#include <SPI.h>\n#endif\n\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n    extern \"C\" void __libc_init_array(void);\n#endif\n    \nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" void Serial_begin(int port, long r)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n        #if(ARDUINO_NUM_SERIAL_PORTS == 4)\n        switch(port) {\n        case 0:\n            Serial.begin(r);\n            break;\n        case 1:\n            Serial1.begin(r);\n            break;\n        case 2:\n            Serial2.begin(r);\n            break;\n        case 3:\n            Serial3.begin(r);\n            break;\n        }\n        #elif(ARDUINO_NUM_SERIAL_PORTS == 2)\n        switch(port) {\n        case 0:\n           Serial.begin(r);\n            break;\n        case 1:\n           Serial1.begin(r);\n            break;\n        }\n        #else\n        Serial.begin(r);\n        #endif\n    #else\n        Serial.begin(r);\n    #endif\n}\n\nextern \"C\" void Serial_read(int port, int showOutStatus, uint8_t *outData, int16_t *outStatus)\n{\n    int libFcnOutput;\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n        #if(ARDUINO_NUM_SERIAL_PORTS == 4)\n            switch(port) {\n            case 0:\n                libFcnOutput = Serial.read();\n                break;\n            case 1:\n                libFcnOutput = Serial1.read();\n                break;\n            case 2:\n                libFcnOutput = Serial2.read();\n                break;\n            case 3:\n                libFcnOutput = Serial3.read();\n                break;\n            }\n        #elif(ARDUINO_NUM_SERIAL_PORTS == 2)\n            switch(port) {\n            case 0:\n                libFcnOutput = Serial.read();\n                break;\n            case 1:\n                libFcnOutput = Serial1.read();\n                break;\n            }\n        #else\n            libFcnOutput = Serial.read();\n        #endif\n    #else\n        libFcnOutput = Serial.read();\n    #endif\n    *outData = (uint8_t) libFcnOutput;\n    *outStatus = (libFcnOutput != -1);\n}\n    \nextern \"C\" void Serial_write(int port, uint8_t * c, size_t s)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n        #if(ARDUINO_NUM_SERIAL_PORTS == 4)\n            switch(port) {\n            case 0:\n                Serial.write(c, s);\n                break;\n            case 1:\n                Serial1.write(c, s);\n                break;\n            case 2:\n                Serial2.write(c, s);\n                break;\n            case 3:\n                Serial3.write(c, s);\n                break;\n            }\n        #elif(ARDUINO_NUM_SERIAL_PORTS == 2)\n            switch(port) {\n            case 0:\n                Serial.write(c, s);\n                break;\n            case 1:\n                Serial1.write(c, s);\n                break;\n            }\n        #else\n            Serial.write(c, s);\n        #endif\n    #else\n        Serial.write(c, s);\n    #endif\n}\n        \n#if _RTT_UDP_ != 0\n    EthernetUDP Udp[_RTT_UDP_];\n    IPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\n    byte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\n    unsigned int localport[_RTT_UDP_] = {_RTT_UDP_LOCAL_PORT_ORDERED};\n    int configureSuccess;\n    int trialcount=0;\n    extern \"C\" uint8_t MW_EthernetAndUDPBegin(uint8_t udpindex, uint32_t localPort)\n    {       \n        static int only_one_ethernet_begin;\n        if (only_one_ethernet_begin==0)\n        {\n          #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n            Ethernet.begin(mac, localIpAddress);\n            configureSuccess = 1;\n          #else\n            configureSuccess = Ethernet.begin(mac);\n          #endif\n            only_one_ethernet_begin++;\n            \n            for(trialcount=0;trialcount<5;trialcount++)\n            {\n                if(Serial)\n                {\n                    break;\n                }else\n                {\n                    delay(1000);\n                }\n            }\n            // Depending on if the IP address assignment using DHCP has been successful or not,\n            // send the appropriate information back to the host.\n            // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as \n            // a part of rtiostream_open\n          #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n                if (configureSuccess==1)\n                {\n                   if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n                    {\n                        /*Tried to assign Static IP, failed due to one of the following reasons :\n                         * 1. Ethernet shield is not connected properly with Arduino.\n                         * 2. Ethernet shield is not connected to a network.\n                         **/\n                        Serial.println(\"<<<IP address: Failed to configure.>>>\");\n                    }\n                    else\n                    {\n                        // If the Configuration is successful, relay back the assigned IP address.\n                        Serial.print(\"<<<IP address: \");\n                        for (byte thisByte = 0; thisByte < 4; thisByte++)\n                        {\n                            // Print the value of each byte of the IP address:\n                            Serial.print(Ethernet.localIP()[thisByte], DEC);\n                            if (thisByte<3)\n                            {\n                                Serial.print(\".\");\n                            }\n                        }\n                        Serial.println(\">>>\");\n                    }     \n                }\n               else\n               {\n                   // If the Configuration failed,relay back the error message.\n                   Serial.println(\"<<<IP address: Failed to configure.>>>\");\n               }\n               Serial.flush();\n          #endif\n        }\n        return (Udp[udpindex].begin(localport[udpindex]));\n    }\n    \n    extern \"C\" int MW_UDPFinalWrite(uint8_t udpindex, uint8_t data, uint8_t remoteIPOctect1,uint8_t remoteIPOctect2,uint8_t remoteIPOctect3,uint8_t remoteIPOctect4, uint32_t remoteport)\n    {\n        IPAddress remoteIpAddress(remoteIPOctect1,remoteIPOctect2, remoteIPOctect3, remoteIPOctect4);\n        Udp[udpindex].beginPacket(remoteIpAddress, remoteport);\n        Udp[udpindex].write(data);\n        return(Udp[udpindex].endPacket());\n    }\n    \n    extern \"C\" void MW_UDPFinalRead(uint8_t udpindex, uint8_t *data, int32_t *outStatus)\n    {\n        int packetSize = Udp[udpindex].parsePacket();\n        if(packetSize)\n        {\n            int libFcnOutput;\n            libFcnOutput = Udp[udpindex].read();\n            *data = (uint8_t) libFcnOutput;\n            *outStatus = (libFcnOutput != -1);\n        }\n        \n        else\n        {\n            //When the client is not connected the status flag is accordingly toggled.\n            *outStatus = 0;\n        }\n    }\n#endif\n    \n#if defined(_RTT_THINGSPEAK_) || (_RTT_TCP_ != 0)\n    IPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\n    byte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\n    int configureSuccess;\n    int trialcount;\n#if _RTT_TCP_ != 0 \n    EthernetServer server[_RTT_TCP_] = {_RTT_TCP_SERVER_PORT_ORDERED};\n#endif\n    extern \"C\" void MW_EthernetAndTCPServerBegin(uint8_t tcpindex, uint32_t serverport)\n    {\n    static int only_one_tcp_server_and_ethernet_begin = 0;\n    \n        if (only_one_tcp_server_and_ethernet_begin==0)\n        {\n          #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n            Ethernet.begin(mac, localIpAddress);\n            configureSuccess = 1;\n          #else\n            configureSuccess = Ethernet.begin(mac);\n          #endif\n            only_one_tcp_server_and_ethernet_begin++;\n            \n             for(trialcount=0;trialcount<5;trialcount++)\n            {\n                if(Serial)\n                {\n                    break;\n                }else\n                {\n                    delay(1000);\n                }\n            }\n            \n            // Depending on if the IP address assignment using DHCP has been successful or not,\n            // send the appropriate information back to the host.\n            // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as \n            // a part of rtiostream_open\n          #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n                if (configureSuccess==1)\n                {\n                   if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n                    {\n                        /*Tried to assign Static IP, failed due to one of the following reasons :\n                         * 1. Ethernet shield is not connected properly with Arduino.\n                         * 2. Ethernet shield is not connected to a network.\n                         **/\n                        Serial.println(\"<<<IP address: Failed to configure.>>>\");\n                    }\n                    else\n                    {\n                        // If the Configuration is successful, relay back the assigned IP address.\n                        Serial.print(\"<<<IP address: \");\n                        for (byte thisByte = 0; thisByte < 4; thisByte++)\n                        {\n                            // Print the value of each byte of the IP address:\n                            Serial.print(Ethernet.localIP()[thisByte], DEC);\n                            if (thisByte<3)\n                            {\n                                Serial.print(\".\");\n                            }\n                        }\n                        Serial.println(\">>>\");\n                    }\n                }\n               else\n               {\n                   // If the Configuration failed,relay back the error message.\n                   Serial.println(\"<<<IP address: Failed to configure.>>>\");\n               }\n               Serial.flush();\n          #endif\n            \n          #if _RTT_TCP_ != 0 \n                 // Begin all servers based on the number of different TCP ports.\n               for (int i = 0;i < _RTT_TCP_;i++)\n               {\n                     server[i].begin();\n                }\n          #endif\n          only_one_tcp_server_and_ethernet_begin = 1;\n        }\n    }\n#endif\n#if _RTT_TCP_ != 0\n    extern \"C\" void MW_TCPFinalread(uint8_t tcpindex, uint8_t *data, uint32_t serverport, int32_t *outStatus)\n    {\n        int libFcnOutput;\n        EthernetClient client = server[tcpindex].available();\n        if (int(client) == true) {\n            libFcnOutput = client.read();\n            *data = (uint8_t) libFcnOutput;\n            *outStatus = (libFcnOutput != -1);\n            \n        }\n        else\n        {\n            //When the client is not connected the status flag is accordingly toggled.\n            *outStatus = 0;\n        }\n        \n    }\n    extern \"C\" void MW_TCPFinalWrite(uint8_t tcpindex, uint8_t data, uint32_t serverport)\n    {\n        server[tcpindex].write(data);\n    }\n#endif\n    \n\n#if defined(_ROTH_LEONARDO_)\nextern \"C\" void MW_usbattach()\n{\n    USBDevice.attach();\n}\n#elif defined(ARDUINO_VIRTUAL_COM_PORT)\nextern \"C\" void MW_usbattach()\n{\n  __libc_init_array();\n  USBDevice.init();\n  USBDevice.attach();\n\n}\n#endif\n\nextern \"C\" void MW_pinModeAnalogInput(uint32_t pinNumber)\n{\n    if (pinNumber < A0)\n        pinNumber += A0;\n    pinMode(pinNumber, INPUT);\n}\n\nextern \"C\" void MW_delay_in_milliseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = millis();\n    while(millis()- start_time <= period) \n    {\n        1;\n    }\n}\n\nextern \"C\" void MW_delay_in_microseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = micros();\n    while(micros()- start_time <= period) \n    {\n        1;\n    }\n}\n\n\n// #if defined(ARDUINO_ARDUINO_NANO33BLE)\n// #include \"Arduino.h\"\n// #include \"pins_arduino.h\"\n// #include \"mbed/drivers/AnalogIn.h\"\n// #include \"mbed.h\"\n// \n// extern uint8_t nano33BLE_dutycycle[21];\n// extern uint16_t nano33BLE_period[21];\n// \n// \n// events::EventQueue queue(32 * EVENTS_EVENT_SIZE);\n// rtos::Thread t;\n// mbed::Ticker tick;\n// \n// static int write_resolution = 8;\n// static int read_resolution = 10;\n// \n// extern \"C\" void MW_NANO33BLE_analogWrite_1(pin_size_t pin, int val, uint16_t period)\n// {\n//   if (pin >= PINS_COUNT) {\n//     return;\n//   }\n//   float percent = (float)val/(float)((1 << write_resolution)-1);\n//   mbed::PwmOut* pwm = digitalPinToPwm(pin);\n//   if (pwm == NULL) {\n//     pwm = new mbed::PwmOut(digitalPinToPinName(pin));\n//     digitalPinToPwm(pin) = pwm;\n//     pwm->period_ms(period); \n//   }\n//   pwm->write(percent);\n// }\n// \n// extern \"C\" void MW_NANO33BLE_PWM_Handler()\n// {\n//     MW_NANO33BLE_analogWrite_1(5, nano33BLE_dutycycle[5], nano33BLE_period[5]);\n// }\n// \n// extern \"C\" void MW_NANO33BLE_PWM_Setup()\n// {\n//   t.start(callback(&queue, &events::EventQueue::dispatch_forever));\n//   tick.attach(queue.event(MW_NANO33BLE_PWM_Handler),_RTT_PWM_PIN5_CST );\n// }\n// \n// \n// \n// \n// extern \"C\" void MW_NANO33BLE_analogWrite(PinName pin, int val, uint16_t period)\n// {\n// //   pin_size_t idx = PinNameToIndex(pin);\n// //   if (idx != NOT_A_PIN) {\n// //     MW_NANO33BLE_analogWrite_1(idx, 50, period);\n// //   } else {\n// //     mbed::PwmOut* pwm = new mbed::PwmOut(pin);\n// //     pwm->period_ms(2); \n// //     float percent = (float)50/(float)((1 << write_resolution)-1);\n// //     pwm->write(percent);\n// //   }\n// }\n// \n// #endif"},{"name":"m3m4m4f_multitasking.c","type":"source","group":"legacy","path":"C:\\Users\\Rafael\\Documents\\GitHub\\Simulink_Adafruit_Motor_Shield_V2_Library\\AFMSV2_Driver_Motor_Test_ert_rtw\\..\\..\\..\\..\\..\\..\\ProgramData\\MATLAB\\SupportPackages\\R2021b\\toolbox\\target\\supportpackages\\armcortexmbase\\scheduler\\src","tag":"","groupDisplay":"Other files","code":"/* Wrapper for Multi tasking.\n * \n * Copyright 2013-2020 The MathWorks, Inc.\n */\n\n\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#include \"MW_target_hardware_resources.h\"\n#endif\n\n#ifndef __NVIC_PRIO_BITS\n#error \"__NVIC_PRIO_BITS is undefined.  The __NVIC_PRIO_BITS is defined in hardware definition header file.\"\n#endif\n\n#include \"mw_force_no_optimization.h\"\n#include \"arm_cortex_m_multitasking.h\"\n\nvolatile uint32_t taskToSchedule;\n\n__attribute__ ((naked,aligned(4))) void PendSV_Handler() {\n    __asm volatile (\n    \"   MRS R0, APSR                            \\n\"\n    \"   PUSH {R0, LR}                           \\n\"\n    \"   MRS R0, BASEPRI                         \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST LR, #0x10                           \\n\"\n    \"   IT EQ                                   \\n\"\n    \"   VMOVEQ S0, S0                           \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   LDR R0, =taskToSchedule                 \\n\"\n    \"   LDR R0, [R0]                            \\n\"\n    \"   PUSH {R0, R1}                           \\n\"\n    \"   SUB SP, SP, #0x20                       \\n\"\n    \"   ADR R0,Call_isr_routine_in_thread_mode \\n\"\n    \"   STR R0,[SP, #24]                        \\n\"\n    \"   MOV R0,#0x01000000                      \\n\"\n    \"   STR R0,[SP, #28]                        \\n\"\n    \"   MVN R0,#0x06                            \\n\"\n    \"   MOV LR, R0                              \\n\"\n    \"   BX LR                                   \\n\"\n    \"Call_isr_routine_in_thread_mode:           \\n\"\n    \"   POP {R0, R1}                            \\n\"\n    \"   BLX R0                                  \\n\"\n    \"   ISB                                     \\n\"\n    \"   SVC #0                                  \\n\"\n    \"Unknown_Execution:                         \\n\"\n    \"   B Unknown_Execution                     \\n\"\n    );\n}\n\n/* SVC Interrupt service routine to restore the context: SVC_Handler*/\n__attribute__ ((naked,aligned(4))) void SVC_Handler(void) {\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n    __asm volatile (\n    \"   TST  LR, #0x10      \\n\"\n    \"   IT EQ               \\n\"\n    \"   VMOVEQ.F32 S0, S0   \\n\"\n    );\n#endif\n    __asm volatile (\n    \"   TST LR, #0x4            \\n\"\n    \"   ITE EQ                  \\n\"\n    \"   MRSEQ R0, MSP           \\n\"\n    \"   MRSNE R0, PSP           \\n\"\n    \"   LDR R1, [R0, #24]       \\n\"\n    \"   LDRB R0, [R1, #-2]      \\n\"\n    \"   CBZ R0, svc_service_0   \\n\"\n    \"   CMP R0, #1              \\n\"\n    \"   BEQ svc_service_1       \\n\"\n    \"   B Unknown_SVC_Request   \\n\"\n    \"svc_service_0:             \\n\"\n    );\n#if (defined(__FPU_PRESENT) && (__FPU_PRESENT == 1)) && (defined(__FPU_USED) && (__FPU_USED == 1))\n     __asm volatile (\n    \"   TST LR, #0x10       \\n\"\n    \"   ITE EQ              \\n\"\n    \"   ADDEQ SP, SP, #104  \\n\"\n    \"   ADDNE SP, SP, #32   \\n\"\n     );\n#else\n     __asm volatile (\"     ADD SP, SP, #32\");\n#endif\n     __asm volatile (\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR BASEPRI, R0           \\n\"\n    \"     POP {R0, R1}              \\n\"\n    \"     MSR APSR_nzcvq, R0        \\n\"\n    \"     BX R1                     \\n\"\n    \"Unknown_SVC_Request:           \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    \"svc_service_1:                 \\n\"\n    \"     MOVW R1, #0x0000ED14      \\n\"\n    \"     MOVT R1, #0xE000          \\n\"\n    \"     LDR R2,[R1]               \\n\"\n    \"     ORR R2, #1                \\n\"\n    \"     STR R2,[R1]               \\n\"\n    \"     BX LR                     \\n\"\n    \"     B Unknown_SVC_Request     \\n\"\n    );\n}\n\n/* LocalWords:  NVIC PRIO TST VMOVEQ ADR isr MOV MVNS asm cpsie chaing arival VMOV MVN\n * LocalWords:  BLX ISB SVC ITE MRSEQ MSP MRSNE PSP LDR LDRB CBZ svc CMP BEQ\n * LocalWords:  ADDEQ ADDNE MSR BASEPRI xff APSR nzcvq MOVW MOVT\n */\n"}]};